<!DOCTYPE html>
        <script>
            /**
             * @fileoverview gl-matrix - High performance matrix and vector operations
             * @author Brandon Jones
             * @author Colin MacKenzie IV
             * @version 2.2.2
             */

            /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
            
            Redistribution and use in source and binary forms, with or without modification,
            are permitted provided that the following conditions are met:
            
              * Redistributions of source code must retain the above copyright notice, this
                list of conditions and the following disclaimer.
              * Redistributions in binary form must reproduce the above copyright notice,
                this list of conditions and the following disclaimer in the documentation
                and/or other materials provided with the distribution.
            
            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
            ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
            WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
            DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
            ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
            (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
            ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
            (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
            SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


            (function (_global) {
                "use strict";

                var shim = {};
                if (typeof (exports) === 'undefined') {
                    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                        shim.exports = {};
                        define(function () {
                            return shim.exports;
                        });
                    } else {
                        // gl-matrix lives in a browser, define its namespaces in global
                        shim.exports = typeof (window) !== 'undefined' ? window : _global;
                    }
                }
                else {
                    // gl-matrix lives in commonjs, define its namespaces in exports
                    shim.exports = exports;
                }

                (function (exports) {
                    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
                
                Redistribution and use in source and binary forms, with or without modification,
                are permitted provided that the following conditions are met:
                
                  * Redistributions of source code must retain the above copyright notice, this
                    list of conditions and the following disclaimer.
                  * Redistributions in binary form must reproduce the above copyright notice,
                    this list of conditions and the following disclaimer in the documentation 
                    and/or other materials provided with the distribution.
                
                THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
                ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
                DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
                ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


                    if (!GLMAT_EPSILON) {
                        var GLMAT_EPSILON = 0.000001;
                    }

                    if (!GLMAT_ARRAY_TYPE) {
                        var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
                    }

                    if (!GLMAT_RANDOM) {
                        var GLMAT_RANDOM = Math.random;
                    }

                    /**
                     * @class Common utilities
                     * @name glMatrix
                     */
                    var glMatrix = {};

                    /**
                     * Sets the type of array used when creating new vectors and matrices
                     *
                     * @param {Type} type Array type, such as Float32Array or Array
                     */
                    glMatrix.setMatrixArrayType = function (type) {
                        GLMAT_ARRAY_TYPE = type;
                    }

                    if (typeof (exports) !== 'undefined') {
                        exports.glMatrix = glMatrix;
                    }

                    var degree = Math.PI / 180;

                    /**
                    * Convert Degree To Radian
                    *
                    * @param {Number} Angle in Degrees
                    */
                    glMatrix.toRadian = function (a) {
                        return a * degree;
                    }
                    ;
                    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
                    
                    Redistribution and use in source and binary forms, with or without modification,
                    are permitted provided that the following conditions are met:
                    
                      * Redistributions of source code must retain the above copyright notice, this
                        list of conditions and the following disclaimer.
                      * Redistributions in binary form must reproduce the above copyright notice,
                        this list of conditions and the following disclaimer in the documentation 
                        and/or other materials provided with the distribution.
                    
                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
                    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
                    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
                    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

                    /**
                     * @class 2 Dimensional Vector
                     * @name vec2
                     */

                    var vec2 = {};

                    /**
                     * Creates a new, empty vec2
                     *
                     * @returns {vec2} a new 2D vector
                     */
                    vec2.create = function () {
                        var out = new GLMAT_ARRAY_TYPE(2);
                        out[0] = 0;
                        out[1] = 0;
                        return out;
                    };

                    /**
                     * Creates a new vec2 initialized with values from an existing vector
                     *
                     * @param {vec2} a vector to clone
                     * @returns {vec2} a new 2D vector
                     */
                    vec2.clone = function (a) {
                        var out = new GLMAT_ARRAY_TYPE(2);
                        out[0] = a[0];
                        out[1] = a[1];
                        return out;
                    };

                    /**
                     * Creates a new vec2 initialized with the given values
                     *
                     * @param {Number} x X component
                     * @param {Number} y Y component
                     * @returns {vec2} a new 2D vector
                     */
                    vec2.fromValues = function (x, y) {
                        var out = new GLMAT_ARRAY_TYPE(2);
                        out[0] = x;
                        out[1] = y;
                        return out;
                    };

                    /**
                     * Copy the values from one vec2 to another
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the source vector
                     * @returns {vec2} out
                     */
                    vec2.copy = function (out, a) {
                        out[0] = a[0];
                        out[1] = a[1];
                        return out;
                    };

                    /**
                     * Set the components of a vec2 to the given values
                     *
                     * @param {vec2} out the receiving vector
                     * @param {Number} x X component
                     * @param {Number} y Y component
                     * @returns {vec2} out
                     */
                    vec2.set = function (out, x, y) {
                        out[0] = x;
                        out[1] = y;
                        return out;
                    };

                    /**
                     * Adds two vec2's
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @returns {vec2} out
                     */
                    vec2.add = function (out, a, b) {
                        out[0] = a[0] + b[0];
                        out[1] = a[1] + b[1];
                        return out;
                    };

                    /**
                     * Subtracts vector b from vector a
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @returns {vec2} out
                     */
                    vec2.subtract = function (out, a, b) {
                        out[0] = a[0] - b[0];
                        out[1] = a[1] - b[1];
                        return out;
                    };

                    /**
                     * Alias for {@link vec2.subtract}
                     * @function
                     */
                    vec2.sub = vec2.subtract;

                    /**
                     * Multiplies two vec2's
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @returns {vec2} out
                     */
                    vec2.multiply = function (out, a, b) {
                        out[0] = a[0] * b[0];
                        out[1] = a[1] * b[1];
                        return out;
                    };

                    /**
                     * Alias for {@link vec2.multiply}
                     * @function
                     */
                    vec2.mul = vec2.multiply;

                    /**
                     * Divides two vec2's
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @returns {vec2} out
                     */
                    vec2.divide = function (out, a, b) {
                        out[0] = a[0] / b[0];
                        out[1] = a[1] / b[1];
                        return out;
                    };

                    /**
                     * Alias for {@link vec2.divide}
                     * @function
                     */
                    vec2.div = vec2.divide;

                    /**
                     * Returns the minimum of two vec2's
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @returns {vec2} out
                     */
                    vec2.min = function (out, a, b) {
                        out[0] = Math.min(a[0], b[0]);
                        out[1] = Math.min(a[1], b[1]);
                        return out;
                    };

                    /**
                     * Returns the maximum of two vec2's
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @returns {vec2} out
                     */
                    vec2.max = function (out, a, b) {
                        out[0] = Math.max(a[0], b[0]);
                        out[1] = Math.max(a[1], b[1]);
                        return out;
                    };

                    /**
                     * Scales a vec2 by a scalar number
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the vector to scale
                     * @param {Number} b amount to scale the vector by
                     * @returns {vec2} out
                     */
                    vec2.scale = function (out, a, b) {
                        out[0] = a[0] * b;
                        out[1] = a[1] * b;
                        return out;
                    };

                    /**
                     * Adds two vec2's after scaling the second operand by a scalar value
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @param {Number} scale the amount to scale b by before adding
                     * @returns {vec2} out
                     */
                    vec2.scaleAndAdd = function (out, a, b, scale) {
                        out[0] = a[0] + (b[0] * scale);
                        out[1] = a[1] + (b[1] * scale);
                        return out;
                    };

                    /**
                     * Calculates the euclidian distance between two vec2's
                     *
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @returns {Number} distance between a and b
                     */
                    vec2.distance = function (a, b) {
                        var x = b[0] - a[0],
                            y = b[1] - a[1];
                        return Math.sqrt(x * x + y * y);
                    };

                    /**
                     * Alias for {@link vec2.distance}
                     * @function
                     */
                    vec2.dist = vec2.distance;

                    /**
                     * Calculates the squared euclidian distance between two vec2's
                     *
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @returns {Number} squared distance between a and b
                     */
                    vec2.squaredDistance = function (a, b) {
                        var x = b[0] - a[0],
                            y = b[1] - a[1];
                        return x * x + y * y;
                    };

                    /**
                     * Alias for {@link vec2.squaredDistance}
                     * @function
                     */
                    vec2.sqrDist = vec2.squaredDistance;

                    /**
                     * Calculates the length of a vec2
                     *
                     * @param {vec2} a vector to calculate length of
                     * @returns {Number} length of a
                     */
                    vec2.length = function (a) {
                        var x = a[0],
                            y = a[1];
                        return Math.sqrt(x * x + y * y);
                    };

                    /**
                     * Alias for {@link vec2.length}
                     * @function
                     */
                    vec2.len = vec2.length;

                    /**
                     * Calculates the squared length of a vec2
                     *
                     * @param {vec2} a vector to calculate squared length of
                     * @returns {Number} squared length of a
                     */
                    vec2.squaredLength = function (a) {
                        var x = a[0],
                            y = a[1];
                        return x * x + y * y;
                    };

                    /**
                     * Alias for {@link vec2.squaredLength}
                     * @function
                     */
                    vec2.sqrLen = vec2.squaredLength;

                    /**
                     * Negates the components of a vec2
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a vector to negate
                     * @returns {vec2} out
                     */
                    vec2.negate = function (out, a) {
                        out[0] = -a[0];
                        out[1] = -a[1];
                        return out;
                    };

                    /**
                     * Returns the inverse of the components of a vec2
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a vector to invert
                     * @returns {vec2} out
                     */
                    vec2.inverse = function (out, a) {
                        out[0] = 1.0 / a[0];
                        out[1] = 1.0 / a[1];
                        return out;
                    };

                    /**
                     * Normalize a vec2
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a vector to normalize
                     * @returns {vec2} out
                     */
                    vec2.normalize = function (out, a) {
                        var x = a[0],
                            y = a[1];
                        var len = x * x + y * y;
                        if (len > 0) {
                            //TODO: evaluate use of glm_invsqrt here?
                            len = 1 / Math.sqrt(len);
                            out[0] = a[0] * len;
                            out[1] = a[1] * len;
                        }
                        return out;
                    };

                    /**
                     * Calculates the dot product of two vec2's
                     *
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @returns {Number} dot product of a and b
                     */
                    vec2.dot = function (a, b) {
                        return a[0] * b[0] + a[1] * b[1];
                    };

                    /**
                     * Computes the cross product of two vec2's
                     * Note that the cross product must by definition produce a 3D vector
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @returns {vec3} out
                     */
                    vec2.cross = function (out, a, b) {
                        var z = a[0] * b[1] - a[1] * b[0];
                        out[0] = out[1] = 0;
                        out[2] = z;
                        return out;
                    };

                    /**
                     * Performs a linear interpolation between two vec2's
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the first operand
                     * @param {vec2} b the second operand
                     * @param {Number} t interpolation amount between the two inputs
                     * @returns {vec2} out
                     */
                    vec2.lerp = function (out, a, b, t) {
                        var ax = a[0],
                            ay = a[1];
                        out[0] = ax + t * (b[0] - ax);
                        out[1] = ay + t * (b[1] - ay);
                        return out;
                    };

                    /**
                     * Generates a random vector with the given scale
                     *
                     * @param {vec2} out the receiving vector
                     * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
                     * @returns {vec2} out
                     */
                    vec2.random = function (out, scale) {
                        scale = scale || 1.0;
                        var r = GLMAT_RANDOM() * 2.0 * Math.PI;
                        out[0] = Math.cos(r) * scale;
                        out[1] = Math.sin(r) * scale;
                        return out;
                    };

                    /**
                     * Transforms the vec2 with a mat2
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the vector to transform
                     * @param {mat2} m matrix to transform with
                     * @returns {vec2} out
                     */
                    vec2.transformMat2 = function (out, a, m) {
                        var x = a[0],
                            y = a[1];
                        out[0] = m[0] * x + m[2] * y;
                        out[1] = m[1] * x + m[3] * y;
                        return out;
                    };

                    /**
                     * Transforms the vec2 with a mat2d
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the vector to transform
                     * @param {mat2d} m matrix to transform with
                     * @returns {vec2} out
                     */
                    vec2.transformMat2d = function (out, a, m) {
                        var x = a[0],
                            y = a[1];
                        out[0] = m[0] * x + m[2] * y + m[4];
                        out[1] = m[1] * x + m[3] * y + m[5];
                        return out;
                    };

                    /**
                     * Transforms the vec2 with a mat3
                     * 3rd vector component is implicitly '1'
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the vector to transform
                     * @param {mat3} m matrix to transform with
                     * @returns {vec2} out
                     */
                    vec2.transformMat3 = function (out, a, m) {
                        var x = a[0],
                            y = a[1];
                        out[0] = m[0] * x + m[3] * y + m[6];
                        out[1] = m[1] * x + m[4] * y + m[7];
                        return out;
                    };

                    /**
                     * Transforms the vec2 with a mat4
                     * 3rd vector component is implicitly '0'
                     * 4th vector component is implicitly '1'
                     *
                     * @param {vec2} out the receiving vector
                     * @param {vec2} a the vector to transform
                     * @param {mat4} m matrix to transform with
                     * @returns {vec2} out
                     */
                    vec2.transformMat4 = function (out, a, m) {
                        var x = a[0],
                            y = a[1];
                        out[0] = m[0] * x + m[4] * y + m[12];
                        out[1] = m[1] * x + m[5] * y + m[13];
                        return out;
                    };

                    /**
                     * Perform some operation over an array of vec2s.
                     *
                     * @param {Array} a the array of vectors to iterate over
                     * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
                     * @param {Number} offset Number of elements to skip at the beginning of the array
                     * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
                     * @param {Function} fn Function to call for each vector in the array
                     * @param {Object} [arg] additional argument to pass to fn
                     * @returns {Array} a
                     * @function
                     */
                    vec2.forEach = (function () {
                        var vec = vec2.create();

                        return function (a, stride, offset, count, fn, arg) {
                            var i, l;
                            if (!stride) {
                                stride = 2;
                            }

                            if (!offset) {
                                offset = 0;
                            }

                            if (count) {
                                l = Math.min((count * stride) + offset, a.length);
                            } else {
                                l = a.length;
                            }

                            for (i = offset; i < l; i += stride) {
                                vec[0] = a[i]; vec[1] = a[i + 1];
                                fn(vec, vec, arg);
                                a[i] = vec[0]; a[i + 1] = vec[1];
                            }

                            return a;
                        };
                    })();

                    /**
                     * Returns a string representation of a vector
                     *
                     * @param {vec2} vec vector to represent as a string
                     * @returns {String} string representation of the vector
                     */
                    vec2.str = function (a) {
                        return 'vec2(' + a[0] + ', ' + a[1] + ')';
                    };

                    if (typeof (exports) !== 'undefined') {
                        exports.vec2 = vec2;
                    }
                    ;
                    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
                    
                    Redistribution and use in source and binary forms, with or without modification,
                    are permitted provided that the following conditions are met:
                    
                      * Redistributions of source code must retain the above copyright notice, this
                        list of conditions and the following disclaimer.
                      * Redistributions in binary form must reproduce the above copyright notice,
                        this list of conditions and the following disclaimer in the documentation 
                        and/or other materials provided with the distribution.
                    
                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
                    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
                    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
                    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

                    /**
                     * @class 3 Dimensional Vector
                     * @name vec3
                     */

                    var vec3 = {};

                    /**
                     * Creates a new, empty vec3
                     *
                     * @returns {vec3} a new 3D vector
                     */
                    vec3.create = function () {
                        var out = new GLMAT_ARRAY_TYPE(3);
                        out[0] = 0;
                        out[1] = 0;
                        out[2] = 0;
                        return out;
                    };

                    /**
                     * Creates a new vec3 initialized with values from an existing vector
                     *
                     * @param {vec3} a vector to clone
                     * @returns {vec3} a new 3D vector
                     */
                    vec3.clone = function (a) {
                        var out = new GLMAT_ARRAY_TYPE(3);
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        return out;
                    };

                    /**
                     * Creates a new vec3 initialized with the given values
                     *
                     * @param {Number} x X component
                     * @param {Number} y Y component
                     * @param {Number} z Z component
                     * @returns {vec3} a new 3D vector
                     */
                    vec3.fromValues = function (x, y, z) {
                        var out = new GLMAT_ARRAY_TYPE(3);
                        out[0] = x;
                        out[1] = y;
                        out[2] = z;
                        return out;
                    };

                    /**
                     * Copy the values from one vec3 to another
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the source vector
                     * @returns {vec3} out
                     */
                    vec3.copy = function (out, a) {
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        return out;
                    };

                    /**
                     * Set the components of a vec3 to the given values
                     *
                     * @param {vec3} out the receiving vector
                     * @param {Number} x X component
                     * @param {Number} y Y component
                     * @param {Number} z Z component
                     * @returns {vec3} out
                     */
                    vec3.set = function (out, x, y, z) {
                        out[0] = x;
                        out[1] = y;
                        out[2] = z;
                        return out;
                    };

                    /**
                     * Adds two vec3's
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @returns {vec3} out
                     */
                    vec3.add = function (out, a, b) {
                        out[0] = a[0] + b[0];
                        out[1] = a[1] + b[1];
                        out[2] = a[2] + b[2];
                        return out;
                    };

                    /**
                     * Subtracts vector b from vector a
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @returns {vec3} out
                     */
                    vec3.subtract = function (out, a, b) {
                        out[0] = a[0] - b[0];
                        out[1] = a[1] - b[1];
                        out[2] = a[2] - b[2];
                        return out;
                    };

                    /**
                     * Alias for {@link vec3.subtract}
                     * @function
                     */
                    vec3.sub = vec3.subtract;

                    /**
                     * Multiplies two vec3's
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @returns {vec3} out
                     */
                    vec3.multiply = function (out, a, b) {
                        out[0] = a[0] * b[0];
                        out[1] = a[1] * b[1];
                        out[2] = a[2] * b[2];
                        return out;
                    };

                    /**
                     * Alias for {@link vec3.multiply}
                     * @function
                     */
                    vec3.mul = vec3.multiply;

                    /**
                     * Divides two vec3's
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @returns {vec3} out
                     */
                    vec3.divide = function (out, a, b) {
                        out[0] = a[0] / b[0];
                        out[1] = a[1] / b[1];
                        out[2] = a[2] / b[2];
                        return out;
                    };

                    /**
                     * Alias for {@link vec3.divide}
                     * @function
                     */
                    vec3.div = vec3.divide;

                    /**
                     * Returns the minimum of two vec3's
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @returns {vec3} out
                     */
                    vec3.min = function (out, a, b) {
                        out[0] = Math.min(a[0], b[0]);
                        out[1] = Math.min(a[1], b[1]);
                        out[2] = Math.min(a[2], b[2]);
                        return out;
                    };

                    /**
                     * Returns the maximum of two vec3's
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @returns {vec3} out
                     */
                    vec3.max = function (out, a, b) {
                        out[0] = Math.max(a[0], b[0]);
                        out[1] = Math.max(a[1], b[1]);
                        out[2] = Math.max(a[2], b[2]);
                        return out;
                    };

                    /**
                     * Scales a vec3 by a scalar number
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the vector to scale
                     * @param {Number} b amount to scale the vector by
                     * @returns {vec3} out
                     */
                    vec3.scale = function (out, a, b) {
                        out[0] = a[0] * b;
                        out[1] = a[1] * b;
                        out[2] = a[2] * b;
                        return out;
                    };

                    /**
                     * Adds two vec3's after scaling the second operand by a scalar value
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @param {Number} scale the amount to scale b by before adding
                     * @returns {vec3} out
                     */
                    vec3.scaleAndAdd = function (out, a, b, scale) {
                        out[0] = a[0] + (b[0] * scale);
                        out[1] = a[1] + (b[1] * scale);
                        out[2] = a[2] + (b[2] * scale);
                        return out;
                    };

                    /**
                     * Calculates the euclidian distance between two vec3's
                     *
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @returns {Number} distance between a and b
                     */
                    vec3.distance = function (a, b) {
                        var x = b[0] - a[0],
                            y = b[1] - a[1],
                            z = b[2] - a[2];
                        return Math.sqrt(x * x + y * y + z * z);
                    };

                    /**
                     * Alias for {@link vec3.distance}
                     * @function
                     */
                    vec3.dist = vec3.distance;

                    /**
                     * Calculates the squared euclidian distance between two vec3's
                     *
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @returns {Number} squared distance between a and b
                     */
                    vec3.squaredDistance = function (a, b) {
                        var x = b[0] - a[0],
                            y = b[1] - a[1],
                            z = b[2] - a[2];
                        return x * x + y * y + z * z;
                    };

                    /**
                     * Alias for {@link vec3.squaredDistance}
                     * @function
                     */
                    vec3.sqrDist = vec3.squaredDistance;

                    /**
                     * Calculates the length of a vec3
                     *
                     * @param {vec3} a vector to calculate length of
                     * @returns {Number} length of a
                     */
                    vec3.length = function (a) {
                        var x = a[0],
                            y = a[1],
                            z = a[2];
                        return Math.sqrt(x * x + y * y + z * z);
                    };

                    /**
                     * Alias for {@link vec3.length}
                     * @function
                     */
                    vec3.len = vec3.length;

                    /**
                     * Calculates the squared length of a vec3
                     *
                     * @param {vec3} a vector to calculate squared length of
                     * @returns {Number} squared length of a
                     */
                    vec3.squaredLength = function (a) {
                        var x = a[0],
                            y = a[1],
                            z = a[2];
                        return x * x + y * y + z * z;
                    };

                    /**
                     * Alias for {@link vec3.squaredLength}
                     * @function
                     */
                    vec3.sqrLen = vec3.squaredLength;

                    /**
                     * Negates the components of a vec3
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a vector to negate
                     * @returns {vec3} out
                     */
                    vec3.negate = function (out, a) {
                        out[0] = -a[0];
                        out[1] = -a[1];
                        out[2] = -a[2];
                        return out;
                    };

                    /**
                     * Returns the inverse of the components of a vec3
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a vector to invert
                     * @returns {vec3} out
                     */
                    vec3.inverse = function (out, a) {
                        out[0] = 1.0 / a[0];
                        out[1] = 1.0 / a[1];
                        out[2] = 1.0 / a[2];
                        return out;
                    };

                    /**
                     * Normalize a vec3
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a vector to normalize
                     * @returns {vec3} out
                     */
                    vec3.normalize = function (out, a) {
                        var x = a[0],
                            y = a[1],
                            z = a[2];
                        var len = x * x + y * y + z * z;
                        if (len > 0) {
                            //TODO: evaluate use of glm_invsqrt here?
                            len = 1 / Math.sqrt(len);
                            out[0] = a[0] * len;
                            out[1] = a[1] * len;
                            out[2] = a[2] * len;
                        }
                        return out;
                    };

                    /**
                     * Calculates the dot product of two vec3's
                     *
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @returns {Number} dot product of a and b
                     */
                    vec3.dot = function (a, b) {
                        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
                    };

                    /**
                     * Computes the cross product of two vec3's
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @returns {vec3} out
                     */
                    vec3.cross = function (out, a, b) {
                        var ax = a[0], ay = a[1], az = a[2],
                            bx = b[0], by = b[1], bz = b[2];

                        out[0] = ay * bz - az * by;
                        out[1] = az * bx - ax * bz;
                        out[2] = ax * by - ay * bx;
                        return out;
                    };

                    /**
                     * Performs a linear interpolation between two vec3's
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the first operand
                     * @param {vec3} b the second operand
                     * @param {Number} t interpolation amount between the two inputs
                     * @returns {vec3} out
                     */
                    vec3.lerp = function (out, a, b, t) {
                        var ax = a[0],
                            ay = a[1],
                            az = a[2];
                        out[0] = ax + t * (b[0] - ax);
                        out[1] = ay + t * (b[1] - ay);
                        out[2] = az + t * (b[2] - az);
                        return out;
                    };

                    /**
                     * Generates a random vector with the given scale
                     *
                     * @param {vec3} out the receiving vector
                     * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
                     * @returns {vec3} out
                     */
                    vec3.random = function (out, scale) {
                        scale = scale || 1.0;

                        var r = GLMAT_RANDOM() * 2.0 * Math.PI;
                        var z = (GLMAT_RANDOM() * 2.0) - 1.0;
                        var zScale = Math.sqrt(1.0 - z * z) * scale;

                        out[0] = Math.cos(r) * zScale;
                        out[1] = Math.sin(r) * zScale;
                        out[2] = z * scale;
                        return out;
                    };

                    /**
                     * Transforms the vec3 with a mat4.
                     * 4th vector component is implicitly '1'
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the vector to transform
                     * @param {mat4} m matrix to transform with
                     * @returns {vec3} out
                     */
                    vec3.transformMat4 = function (out, a, m) {
                        var x = a[0], y = a[1], z = a[2],
                            w = m[3] * x + m[7] * y + m[11] * z + m[15];
                        w = w || 1.0;
                        out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
                        out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
                        out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
                        return out;
                    };

                    /**
                     * Transforms the vec3 with a mat3.
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the vector to transform
                     * @param {mat4} m the 3x3 matrix to transform with
                     * @returns {vec3} out
                     */
                    vec3.transformMat3 = function (out, a, m) {
                        var x = a[0], y = a[1], z = a[2];
                        out[0] = x * m[0] + y * m[3] + z * m[6];
                        out[1] = x * m[1] + y * m[4] + z * m[7];
                        out[2] = x * m[2] + y * m[5] + z * m[8];
                        return out;
                    };

                    /**
                     * Transforms the vec3 with a quat
                     *
                     * @param {vec3} out the receiving vector
                     * @param {vec3} a the vector to transform
                     * @param {quat} q quaternion to transform with
                     * @returns {vec3} out
                     */
                    vec3.transformQuat = function (out, a, q) {
                        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

                        var x = a[0], y = a[1], z = a[2],
                            qx = q[0], qy = q[1], qz = q[2], qw = q[3],

                            // calculate quat * vec
                            ix = qw * x + qy * z - qz * y,
                            iy = qw * y + qz * x - qx * z,
                            iz = qw * z + qx * y - qy * x,
                            iw = -qx * x - qy * y - qz * z;

                        // calculate result * inverse quat
                        out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                        out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                        out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                        return out;
                    };

                    /**
                     * Rotate a 3D vector around the x-axis
                     * @param {vec3} out The receiving vec3
                     * @param {vec3} a The vec3 point to rotate
                     * @param {vec3} b The origin of the rotation
                     * @param {Number} c The angle of rotation
                     * @returns {vec3} out
                     */
                    vec3.rotateX = function (out, a, b, c) {
                        var p = [], r = [];
                        //Translate point to the origin
                        p[0] = a[0] - b[0];
                        p[1] = a[1] - b[1];
                        p[2] = a[2] - b[2];

                        //perform rotation
                        r[0] = p[0];
                        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
                        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

                        //translate to correct position
                        out[0] = r[0] + b[0];
                        out[1] = r[1] + b[1];
                        out[2] = r[2] + b[2];

                        return out;
                    };

                    /**
                     * Rotate a 3D vector around the y-axis
                     * @param {vec3} out The receiving vec3
                     * @param {vec3} a The vec3 point to rotate
                     * @param {vec3} b The origin of the rotation
                     * @param {Number} c The angle of rotation
                     * @returns {vec3} out
                     */
                    vec3.rotateY = function (out, a, b, c) {
                        var p = [], r = [];
                        //Translate point to the origin
                        p[0] = a[0] - b[0];
                        p[1] = a[1] - b[1];
                        p[2] = a[2] - b[2];

                        //perform rotation
                        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
                        r[1] = p[1];
                        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

                        //translate to correct position
                        out[0] = r[0] + b[0];
                        out[1] = r[1] + b[1];
                        out[2] = r[2] + b[2];

                        return out;
                    };

                    /**
                     * Rotate a 3D vector around the z-axis
                     * @param {vec3} out The receiving vec3
                     * @param {vec3} a The vec3 point to rotate
                     * @param {vec3} b The origin of the rotation
                     * @param {Number} c The angle of rotation
                     * @returns {vec3} out
                     */
                    vec3.rotateZ = function (out, a, b, c) {
                        var p = [], r = [];
                        //Translate point to the origin
                        p[0] = a[0] - b[0];
                        p[1] = a[1] - b[1];
                        p[2] = a[2] - b[2];

                        //perform rotation
                        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
                        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
                        r[2] = p[2];

                        //translate to correct position
                        out[0] = r[0] + b[0];
                        out[1] = r[1] + b[1];
                        out[2] = r[2] + b[2];

                        return out;
                    };

                    /**
                     * Perform some operation over an array of vec3s.
                     *
                     * @param {Array} a the array of vectors to iterate over
                     * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
                     * @param {Number} offset Number of elements to skip at the beginning of the array
                     * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
                     * @param {Function} fn Function to call for each vector in the array
                     * @param {Object} [arg] additional argument to pass to fn
                     * @returns {Array} a
                     * @function
                     */
                    vec3.forEach = (function () {
                        var vec = vec3.create();

                        return function (a, stride, offset, count, fn, arg) {
                            var i, l;
                            if (!stride) {
                                stride = 3;
                            }

                            if (!offset) {
                                offset = 0;
                            }

                            if (count) {
                                l = Math.min((count * stride) + offset, a.length);
                            } else {
                                l = a.length;
                            }

                            for (i = offset; i < l; i += stride) {
                                vec[0] = a[i]; vec[1] = a[i + 1]; vec[2] = a[i + 2];
                                fn(vec, vec, arg);
                                a[i] = vec[0]; a[i + 1] = vec[1]; a[i + 2] = vec[2];
                            }

                            return a;
                        };
                    })();

                    /**
                     * Get the angle between two 3D vectors
                     * @param {vec3} a The first operand
                     * @param {vec3} b The second operand
                     * @returns {Number} The angle in radians
                     */
                    vec3.angle = function (a, b) {

                        var tempA = vec3.fromValues(a[0], a[1], a[2]);
                        var tempB = vec3.fromValues(b[0], b[1], b[2]);

                        vec3.normalize(tempA, tempA);
                        vec3.normalize(tempB, tempB);

                        var cosine = vec3.dot(tempA, tempB);

                        if (cosine > 1.0) {
                            return 0;
                        } else {
                            return Math.acos(cosine);
                        }
                    };

                    /**
                     * Returns a string representation of a vector
                     *
                     * @param {vec3} vec vector to represent as a string
                     * @returns {String} string representation of the vector
                     */
                    vec3.str = function (a) {
                        return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
                    };

                    if (typeof (exports) !== 'undefined') {
                        exports.vec3 = vec3;
                    }
                    ;
                    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
                    
                    Redistribution and use in source and binary forms, with or without modification,
                    are permitted provided that the following conditions are met:
                    
                      * Redistributions of source code must retain the above copyright notice, this
                        list of conditions and the following disclaimer.
                      * Redistributions in binary form must reproduce the above copyright notice,
                        this list of conditions and the following disclaimer in the documentation 
                        and/or other materials provided with the distribution.
                    
                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
                    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
                    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
                    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

                    /**
                     * @class 4 Dimensional Vector
                     * @name vec4
                     */

                    var vec4 = {};

                    /**
                     * Creates a new, empty vec4
                     *
                     * @returns {vec4} a new 4D vector
                     */
                    vec4.create = function () {
                        var out = new GLMAT_ARRAY_TYPE(4);
                        out[0] = 0;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        return out;
                    };

                    /**
                     * Creates a new vec4 initialized with values from an existing vector
                     *
                     * @param {vec4} a vector to clone
                     * @returns {vec4} a new 4D vector
                     */
                    vec4.clone = function (a) {
                        var out = new GLMAT_ARRAY_TYPE(4);
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        return out;
                    };

                    /**
                     * Creates a new vec4 initialized with the given values
                     *
                     * @param {Number} x X component
                     * @param {Number} y Y component
                     * @param {Number} z Z component
                     * @param {Number} w W component
                     * @returns {vec4} a new 4D vector
                     */
                    vec4.fromValues = function (x, y, z, w) {
                        var out = new GLMAT_ARRAY_TYPE(4);
                        out[0] = x;
                        out[1] = y;
                        out[2] = z;
                        out[3] = w;
                        return out;
                    };

                    /**
                     * Copy the values from one vec4 to another
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the source vector
                     * @returns {vec4} out
                     */
                    vec4.copy = function (out, a) {
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        return out;
                    };

                    /**
                     * Set the components of a vec4 to the given values
                     *
                     * @param {vec4} out the receiving vector
                     * @param {Number} x X component
                     * @param {Number} y Y component
                     * @param {Number} z Z component
                     * @param {Number} w W component
                     * @returns {vec4} out
                     */
                    vec4.set = function (out, x, y, z, w) {
                        out[0] = x;
                        out[1] = y;
                        out[2] = z;
                        out[3] = w;
                        return out;
                    };

                    /**
                     * Adds two vec4's
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @returns {vec4} out
                     */
                    vec4.add = function (out, a, b) {
                        out[0] = a[0] + b[0];
                        out[1] = a[1] + b[1];
                        out[2] = a[2] + b[2];
                        out[3] = a[3] + b[3];
                        return out;
                    };

                    /**
                     * Subtracts vector b from vector a
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @returns {vec4} out
                     */
                    vec4.subtract = function (out, a, b) {
                        out[0] = a[0] - b[0];
                        out[1] = a[1] - b[1];
                        out[2] = a[2] - b[2];
                        out[3] = a[3] - b[3];
                        return out;
                    };

                    /**
                     * Alias for {@link vec4.subtract}
                     * @function
                     */
                    vec4.sub = vec4.subtract;

                    /**
                     * Multiplies two vec4's
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @returns {vec4} out
                     */
                    vec4.multiply = function (out, a, b) {
                        out[0] = a[0] * b[0];
                        out[1] = a[1] * b[1];
                        out[2] = a[2] * b[2];
                        out[3] = a[3] * b[3];
                        return out;
                    };

                    /**
                     * Alias for {@link vec4.multiply}
                     * @function
                     */
                    vec4.mul = vec4.multiply;

                    /**
                     * Divides two vec4's
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @returns {vec4} out
                     */
                    vec4.divide = function (out, a, b) {
                        out[0] = a[0] / b[0];
                        out[1] = a[1] / b[1];
                        out[2] = a[2] / b[2];
                        out[3] = a[3] / b[3];
                        return out;
                    };

                    /**
                     * Alias for {@link vec4.divide}
                     * @function
                     */
                    vec4.div = vec4.divide;

                    /**
                     * Returns the minimum of two vec4's
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @returns {vec4} out
                     */
                    vec4.min = function (out, a, b) {
                        out[0] = Math.min(a[0], b[0]);
                        out[1] = Math.min(a[1], b[1]);
                        out[2] = Math.min(a[2], b[2]);
                        out[3] = Math.min(a[3], b[3]);
                        return out;
                    };

                    /**
                     * Returns the maximum of two vec4's
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @returns {vec4} out
                     */
                    vec4.max = function (out, a, b) {
                        out[0] = Math.max(a[0], b[0]);
                        out[1] = Math.max(a[1], b[1]);
                        out[2] = Math.max(a[2], b[2]);
                        out[3] = Math.max(a[3], b[3]);
                        return out;
                    };

                    /**
                     * Scales a vec4 by a scalar number
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the vector to scale
                     * @param {Number} b amount to scale the vector by
                     * @returns {vec4} out
                     */
                    vec4.scale = function (out, a, b) {
                        out[0] = a[0] * b;
                        out[1] = a[1] * b;
                        out[2] = a[2] * b;
                        out[3] = a[3] * b;
                        return out;
                    };

                    /**
                     * Adds two vec4's after scaling the second operand by a scalar value
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @param {Number} scale the amount to scale b by before adding
                     * @returns {vec4} out
                     */
                    vec4.scaleAndAdd = function (out, a, b, scale) {
                        out[0] = a[0] + (b[0] * scale);
                        out[1] = a[1] + (b[1] * scale);
                        out[2] = a[2] + (b[2] * scale);
                        out[3] = a[3] + (b[3] * scale);
                        return out;
                    };

                    /**
                     * Calculates the euclidian distance between two vec4's
                     *
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @returns {Number} distance between a and b
                     */
                    vec4.distance = function (a, b) {
                        var x = b[0] - a[0],
                            y = b[1] - a[1],
                            z = b[2] - a[2],
                            w = b[3] - a[3];
                        return Math.sqrt(x * x + y * y + z * z + w * w);
                    };

                    /**
                     * Alias for {@link vec4.distance}
                     * @function
                     */
                    vec4.dist = vec4.distance;

                    /**
                     * Calculates the squared euclidian distance between two vec4's
                     *
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @returns {Number} squared distance between a and b
                     */
                    vec4.squaredDistance = function (a, b) {
                        var x = b[0] - a[0],
                            y = b[1] - a[1],
                            z = b[2] - a[2],
                            w = b[3] - a[3];
                        return x * x + y * y + z * z + w * w;
                    };

                    /**
                     * Alias for {@link vec4.squaredDistance}
                     * @function
                     */
                    vec4.sqrDist = vec4.squaredDistance;

                    /**
                     * Calculates the length of a vec4
                     *
                     * @param {vec4} a vector to calculate length of
                     * @returns {Number} length of a
                     */
                    vec4.length = function (a) {
                        var x = a[0],
                            y = a[1],
                            z = a[2],
                            w = a[3];
                        return Math.sqrt(x * x + y * y + z * z + w * w);
                    };

                    /**
                     * Alias for {@link vec4.length}
                     * @function
                     */
                    vec4.len = vec4.length;

                    /**
                     * Calculates the squared length of a vec4
                     *
                     * @param {vec4} a vector to calculate squared length of
                     * @returns {Number} squared length of a
                     */
                    vec4.squaredLength = function (a) {
                        var x = a[0],
                            y = a[1],
                            z = a[2],
                            w = a[3];
                        return x * x + y * y + z * z + w * w;
                    };

                    /**
                     * Alias for {@link vec4.squaredLength}
                     * @function
                     */
                    vec4.sqrLen = vec4.squaredLength;

                    /**
                     * Negates the components of a vec4
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a vector to negate
                     * @returns {vec4} out
                     */
                    vec4.negate = function (out, a) {
                        out[0] = -a[0];
                        out[1] = -a[1];
                        out[2] = -a[2];
                        out[3] = -a[3];
                        return out;
                    };

                    /**
                     * Returns the inverse of the components of a vec4
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a vector to invert
                     * @returns {vec4} out
                     */
                    vec4.inverse = function (out, a) {
                        out[0] = 1.0 / a[0];
                        out[1] = 1.0 / a[1];
                        out[2] = 1.0 / a[2];
                        out[3] = 1.0 / a[3];
                        return out;
                    };

                    /**
                     * Normalize a vec4
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a vector to normalize
                     * @returns {vec4} out
                     */
                    vec4.normalize = function (out, a) {
                        var x = a[0],
                            y = a[1],
                            z = a[2],
                            w = a[3];
                        var len = x * x + y * y + z * z + w * w;
                        if (len > 0) {
                            len = 1 / Math.sqrt(len);
                            out[0] = a[0] * len;
                            out[1] = a[1] * len;
                            out[2] = a[2] * len;
                            out[3] = a[3] * len;
                        }
                        return out;
                    };

                    /**
                     * Calculates the dot product of two vec4's
                     *
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @returns {Number} dot product of a and b
                     */
                    vec4.dot = function (a, b) {
                        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
                    };

                    /**
                     * Performs a linear interpolation between two vec4's
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the first operand
                     * @param {vec4} b the second operand
                     * @param {Number} t interpolation amount between the two inputs
                     * @returns {vec4} out
                     */
                    vec4.lerp = function (out, a, b, t) {
                        var ax = a[0],
                            ay = a[1],
                            az = a[2],
                            aw = a[3];
                        out[0] = ax + t * (b[0] - ax);
                        out[1] = ay + t * (b[1] - ay);
                        out[2] = az + t * (b[2] - az);
                        out[3] = aw + t * (b[3] - aw);
                        return out;
                    };

                    /**
                     * Generates a random vector with the given scale
                     *
                     * @param {vec4} out the receiving vector
                     * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
                     * @returns {vec4} out
                     */
                    vec4.random = function (out, scale) {
                        scale = scale || 1.0;

                        //TODO: This is a pretty awful way of doing this. Find something better.
                        out[0] = GLMAT_RANDOM();
                        out[1] = GLMAT_RANDOM();
                        out[2] = GLMAT_RANDOM();
                        out[3] = GLMAT_RANDOM();
                        vec4.normalize(out, out);
                        vec4.scale(out, out, scale);
                        return out;
                    };

                    /**
                     * Transforms the vec4 with a mat4.
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the vector to transform
                     * @param {mat4} m matrix to transform with
                     * @returns {vec4} out
                     */
                    vec4.transformMat4 = function (out, a, m) {
                        var x = a[0], y = a[1], z = a[2], w = a[3];
                        out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
                        out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
                        out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
                        out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
                        return out;
                    };

                    /**
                     * Transforms the vec4 with a quat
                     *
                     * @param {vec4} out the receiving vector
                     * @param {vec4} a the vector to transform
                     * @param {quat} q quaternion to transform with
                     * @returns {vec4} out
                     */
                    vec4.transformQuat = function (out, a, q) {
                        var x = a[0], y = a[1], z = a[2],
                            qx = q[0], qy = q[1], qz = q[2], qw = q[3],

                            // calculate quat * vec
                            ix = qw * x + qy * z - qz * y,
                            iy = qw * y + qz * x - qx * z,
                            iz = qw * z + qx * y - qy * x,
                            iw = -qx * x - qy * y - qz * z;

                        // calculate result * inverse quat
                        out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                        out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                        out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                        return out;
                    };

                    /**
                     * Perform some operation over an array of vec4s.
                     *
                     * @param {Array} a the array of vectors to iterate over
                     * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
                     * @param {Number} offset Number of elements to skip at the beginning of the array
                     * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
                     * @param {Function} fn Function to call for each vector in the array
                     * @param {Object} [arg] additional argument to pass to fn
                     * @returns {Array} a
                     * @function
                     */
                    vec4.forEach = (function () {
                        var vec = vec4.create();

                        return function (a, stride, offset, count, fn, arg) {
                            var i, l;
                            if (!stride) {
                                stride = 4;
                            }

                            if (!offset) {
                                offset = 0;
                            }

                            if (count) {
                                l = Math.min((count * stride) + offset, a.length);
                            } else {
                                l = a.length;
                            }

                            for (i = offset; i < l; i += stride) {
                                vec[0] = a[i]; vec[1] = a[i + 1]; vec[2] = a[i + 2]; vec[3] = a[i + 3];
                                fn(vec, vec, arg);
                                a[i] = vec[0]; a[i + 1] = vec[1]; a[i + 2] = vec[2]; a[i + 3] = vec[3];
                            }

                            return a;
                        };
                    })();

                    /**
                     * Returns a string representation of a vector
                     *
                     * @param {vec4} vec vector to represent as a string
                     * @returns {String} string representation of the vector
                     */
                    vec4.str = function (a) {
                        return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
                    };

                    if (typeof (exports) !== 'undefined') {
                        exports.vec4 = vec4;
                    }
                    ;
                    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
                    
                    Redistribution and use in source and binary forms, with or without modification,
                    are permitted provided that the following conditions are met:
                    
                      * Redistributions of source code must retain the above copyright notice, this
                        list of conditions and the following disclaimer.
                      * Redistributions in binary form must reproduce the above copyright notice,
                        this list of conditions and the following disclaimer in the documentation 
                        and/or other materials provided with the distribution.
                    
                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
                    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
                    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
                    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

                    /**
                     * @class 2x2 Matrix
                     * @name mat2
                     */

                    var mat2 = {};

                    /**
                     * Creates a new identity mat2
                     *
                     * @returns {mat2} a new 2x2 matrix
                     */
                    mat2.create = function () {
                        var out = new GLMAT_ARRAY_TYPE(4);
                        out[0] = 1;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 1;
                        return out;
                    };

                    /**
                     * Creates a new mat2 initialized with values from an existing matrix
                     *
                     * @param {mat2} a matrix to clone
                     * @returns {mat2} a new 2x2 matrix
                     */
                    mat2.clone = function (a) {
                        var out = new GLMAT_ARRAY_TYPE(4);
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        return out;
                    };

                    /**
                     * Copy the values from one mat2 to another
                     *
                     * @param {mat2} out the receiving matrix
                     * @param {mat2} a the source matrix
                     * @returns {mat2} out
                     */
                    mat2.copy = function (out, a) {
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        return out;
                    };

                    /**
                     * Set a mat2 to the identity matrix
                     *
                     * @param {mat2} out the receiving matrix
                     * @returns {mat2} out
                     */
                    mat2.identity = function (out) {
                        out[0] = 1;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 1;
                        return out;
                    };

                    /**
                     * Transpose the values of a mat2
                     *
                     * @param {mat2} out the receiving matrix
                     * @param {mat2} a the source matrix
                     * @returns {mat2} out
                     */
                    mat2.transpose = function (out, a) {
                        // If we are transposing ourselves we can skip a few steps but have to cache some values
                        if (out === a) {
                            var a1 = a[1];
                            out[1] = a[2];
                            out[2] = a1;
                        } else {
                            out[0] = a[0];
                            out[1] = a[2];
                            out[2] = a[1];
                            out[3] = a[3];
                        }

                        return out;
                    };

                    /**
                     * Inverts a mat2
                     *
                     * @param {mat2} out the receiving matrix
                     * @param {mat2} a the source matrix
                     * @returns {mat2} out
                     */
                    mat2.invert = function (out, a) {
                        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

                            // Calculate the determinant
                            det = a0 * a3 - a2 * a1;

                        if (!det) {
                            return null;
                        }
                        det = 1.0 / det;

                        out[0] = a3 * det;
                        out[1] = -a1 * det;
                        out[2] = -a2 * det;
                        out[3] = a0 * det;

                        return out;
                    };

                    /**
                     * Calculates the adjugate of a mat2
                     *
                     * @param {mat2} out the receiving matrix
                     * @param {mat2} a the source matrix
                     * @returns {mat2} out
                     */
                    mat2.adjoint = function (out, a) {
                        // Caching this value is nessecary if out == a
                        var a0 = a[0];
                        out[0] = a[3];
                        out[1] = -a[1];
                        out[2] = -a[2];
                        out[3] = a0;

                        return out;
                    };

                    /**
                     * Calculates the determinant of a mat2
                     *
                     * @param {mat2} a the source matrix
                     * @returns {Number} determinant of a
                     */
                    mat2.determinant = function (a) {
                        return a[0] * a[3] - a[2] * a[1];
                    };

                    /**
                     * Multiplies two mat2's
                     *
                     * @param {mat2} out the receiving matrix
                     * @param {mat2} a the first operand
                     * @param {mat2} b the second operand
                     * @returns {mat2} out
                     */
                    mat2.multiply = function (out, a, b) {
                        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
                        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                        out[0] = a0 * b0 + a2 * b1;
                        out[1] = a1 * b0 + a3 * b1;
                        out[2] = a0 * b2 + a2 * b3;
                        out[3] = a1 * b2 + a3 * b3;
                        return out;
                    };

                    /**
                     * Alias for {@link mat2.multiply}
                     * @function
                     */
                    mat2.mul = mat2.multiply;

                    /**
                     * Rotates a mat2 by the given angle
                     *
                     * @param {mat2} out the receiving matrix
                     * @param {mat2} a the matrix to rotate
                     * @param {Number} rad the angle to rotate the matrix by
                     * @returns {mat2} out
                     */
                    mat2.rotate = function (out, a, rad) {
                        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
                            s = Math.sin(rad),
                            c = Math.cos(rad);
                        out[0] = a0 * c + a2 * s;
                        out[1] = a1 * c + a3 * s;
                        out[2] = a0 * -s + a2 * c;
                        out[3] = a1 * -s + a3 * c;
                        return out;
                    };

                    /**
                     * Scales the mat2 by the dimensions in the given vec2
                     *
                     * @param {mat2} out the receiving matrix
                     * @param {mat2} a the matrix to rotate
                     * @param {vec2} v the vec2 to scale the matrix by
                     * @returns {mat2} out
                     **/
                    mat2.scale = function (out, a, v) {
                        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
                            v0 = v[0], v1 = v[1];
                        out[0] = a0 * v0;
                        out[1] = a1 * v0;
                        out[2] = a2 * v1;
                        out[3] = a3 * v1;
                        return out;
                    };

                    /**
                     * Returns a string representation of a mat2
                     *
                     * @param {mat2} mat matrix to represent as a string
                     * @returns {String} string representation of the matrix
                     */
                    mat2.str = function (a) {
                        return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
                    };

                    /**
                     * Returns Frobenius norm of a mat2
                     *
                     * @param {mat2} a the matrix to calculate Frobenius norm of
                     * @returns {Number} Frobenius norm
                     */
                    mat2.frob = function (a) {
                        return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
                    };

                    /**
                     * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
                     * @param {mat2} L the lower triangular matrix 
                     * @param {mat2} D the diagonal matrix 
                     * @param {mat2} U the upper triangular matrix 
                     * @param {mat2} a the input matrix to factorize
                     */

                    mat2.LDU = function (L, D, U, a) {
                        L[2] = a[2] / a[0];
                        U[0] = a[0];
                        U[1] = a[1];
                        U[3] = a[3] - L[2] * U[1];
                        return [L, D, U];
                    };

                    if (typeof (exports) !== 'undefined') {
                        exports.mat2 = mat2;
                    }
                    ;
                    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
                    
                    Redistribution and use in source and binary forms, with or without modification,
                    are permitted provided that the following conditions are met:
                    
                      * Redistributions of source code must retain the above copyright notice, this
                        list of conditions and the following disclaimer.
                      * Redistributions in binary form must reproduce the above copyright notice,
                        this list of conditions and the following disclaimer in the documentation 
                        and/or other materials provided with the distribution.
                    
                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
                    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
                    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
                    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

                    /**
                     * @class 2x3 Matrix
                     * @name mat2d
                     * 
                     * @description 
                     * A mat2d contains six elements defined as:
                     * <pre>
                     * [a, c, tx,
                     *  b, d, ty]
                     * </pre>
                     * This is a short form for the 3x3 matrix:
                     * <pre>
                     * [a, c, tx,
                     *  b, d, ty,
                     *  0, 0, 1]
                     * </pre>
                     * The last row is ignored so the array is shorter and operations are faster.
                     */

                    var mat2d = {};

                    /**
                     * Creates a new identity mat2d
                     *
                     * @returns {mat2d} a new 2x3 matrix
                     */
                    mat2d.create = function () {
                        var out = new GLMAT_ARRAY_TYPE(6);
                        out[0] = 1;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 1;
                        out[4] = 0;
                        out[5] = 0;
                        return out;
                    };

                    /**
                     * Creates a new mat2d initialized with values from an existing matrix
                     *
                     * @param {mat2d} a matrix to clone
                     * @returns {mat2d} a new 2x3 matrix
                     */
                    mat2d.clone = function (a) {
                        var out = new GLMAT_ARRAY_TYPE(6);
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        out[4] = a[4];
                        out[5] = a[5];
                        return out;
                    };

                    /**
                     * Copy the values from one mat2d to another
                     *
                     * @param {mat2d} out the receiving matrix
                     * @param {mat2d} a the source matrix
                     * @returns {mat2d} out
                     */
                    mat2d.copy = function (out, a) {
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        out[4] = a[4];
                        out[5] = a[5];
                        return out;
                    };

                    /**
                     * Set a mat2d to the identity matrix
                     *
                     * @param {mat2d} out the receiving matrix
                     * @returns {mat2d} out
                     */
                    mat2d.identity = function (out) {
                        out[0] = 1;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 1;
                        out[4] = 0;
                        out[5] = 0;
                        return out;
                    };

                    /**
                     * Inverts a mat2d
                     *
                     * @param {mat2d} out the receiving matrix
                     * @param {mat2d} a the source matrix
                     * @returns {mat2d} out
                     */
                    mat2d.invert = function (out, a) {
                        var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
                            atx = a[4], aty = a[5];

                        var det = aa * ad - ab * ac;
                        if (!det) {
                            return null;
                        }
                        det = 1.0 / det;

                        out[0] = ad * det;
                        out[1] = -ab * det;
                        out[2] = -ac * det;
                        out[3] = aa * det;
                        out[4] = (ac * aty - ad * atx) * det;
                        out[5] = (ab * atx - aa * aty) * det;
                        return out;
                    };

                    /**
                     * Calculates the determinant of a mat2d
                     *
                     * @param {mat2d} a the source matrix
                     * @returns {Number} determinant of a
                     */
                    mat2d.determinant = function (a) {
                        return a[0] * a[3] - a[1] * a[2];
                    };

                    /**
                     * Multiplies two mat2d's
                     *
                     * @param {mat2d} out the receiving matrix
                     * @param {mat2d} a the first operand
                     * @param {mat2d} b the second operand
                     * @returns {mat2d} out
                     */
                    mat2d.multiply = function (out, a, b) {
                        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
                            b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
                        out[0] = a0 * b0 + a2 * b1;
                        out[1] = a1 * b0 + a3 * b1;
                        out[2] = a0 * b2 + a2 * b3;
                        out[3] = a1 * b2 + a3 * b3;
                        out[4] = a0 * b4 + a2 * b5 + a4;
                        out[5] = a1 * b4 + a3 * b5 + a5;
                        return out;
                    };

                    /**
                     * Alias for {@link mat2d.multiply}
                     * @function
                     */
                    mat2d.mul = mat2d.multiply;


                    /**
                     * Rotates a mat2d by the given angle
                     *
                     * @param {mat2d} out the receiving matrix
                     * @param {mat2d} a the matrix to rotate
                     * @param {Number} rad the angle to rotate the matrix by
                     * @returns {mat2d} out
                     */
                    mat2d.rotate = function (out, a, rad) {
                        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
                            s = Math.sin(rad),
                            c = Math.cos(rad);
                        out[0] = a0 * c + a2 * s;
                        out[1] = a1 * c + a3 * s;
                        out[2] = a0 * -s + a2 * c;
                        out[3] = a1 * -s + a3 * c;
                        out[4] = a4;
                        out[5] = a5;
                        return out;
                    };

                    /**
                     * Scales the mat2d by the dimensions in the given vec2
                     *
                     * @param {mat2d} out the receiving matrix
                     * @param {mat2d} a the matrix to translate
                     * @param {vec2} v the vec2 to scale the matrix by
                     * @returns {mat2d} out
                     **/
                    mat2d.scale = function (out, a, v) {
                        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
                            v0 = v[0], v1 = v[1];
                        out[0] = a0 * v0;
                        out[1] = a1 * v0;
                        out[2] = a2 * v1;
                        out[3] = a3 * v1;
                        out[4] = a4;
                        out[5] = a5;
                        return out;
                    };

                    /**
                     * Translates the mat2d by the dimensions in the given vec2
                     *
                     * @param {mat2d} out the receiving matrix
                     * @param {mat2d} a the matrix to translate
                     * @param {vec2} v the vec2 to translate the matrix by
                     * @returns {mat2d} out
                     **/
                    mat2d.translate = function (out, a, v) {
                        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
                            v0 = v[0], v1 = v[1];
                        out[0] = a0;
                        out[1] = a1;
                        out[2] = a2;
                        out[3] = a3;
                        out[4] = a0 * v0 + a2 * v1 + a4;
                        out[5] = a1 * v0 + a3 * v1 + a5;
                        return out;
                    };

                    /**
                     * Returns a string representation of a mat2d
                     *
                     * @param {mat2d} a matrix to represent as a string
                     * @returns {String} string representation of the matrix
                     */
                    mat2d.str = function (a) {
                        return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
                                        a[3] + ', ' + a[4] + ', ' + a[5] + ')';
                    };

                    /**
                     * Returns Frobenius norm of a mat2d
                     *
                     * @param {mat2d} a the matrix to calculate Frobenius norm of
                     * @returns {Number} Frobenius norm
                     */
                    mat2d.frob = function (a) {
                        return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
                    };

                    if (typeof (exports) !== 'undefined') {
                        exports.mat2d = mat2d;
                    }
                    ;
                    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
                    
                    Redistribution and use in source and binary forms, with or without modification,
                    are permitted provided that the following conditions are met:
                    
                      * Redistributions of source code must retain the above copyright notice, this
                        list of conditions and the following disclaimer.
                      * Redistributions in binary form must reproduce the above copyright notice,
                        this list of conditions and the following disclaimer in the documentation 
                        and/or other materials provided with the distribution.
                    
                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
                    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
                    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
                    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

                    /**
                     * @class 3x3 Matrix
                     * @name mat3
                     */

                    var mat3 = {};

                    /**
                     * Creates a new identity mat3
                     *
                     * @returns {mat3} a new 3x3 matrix
                     */
                    mat3.create = function () {
                        var out = new GLMAT_ARRAY_TYPE(9);
                        out[0] = 1;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        out[4] = 1;
                        out[5] = 0;
                        out[6] = 0;
                        out[7] = 0;
                        out[8] = 1;
                        return out;
                    };

                    /**
                     * Copies the upper-left 3x3 values into the given mat3.
                     *
                     * @param {mat3} out the receiving 3x3 matrix
                     * @param {mat4} a   the source 4x4 matrix
                     * @returns {mat3} out
                     */
                    mat3.fromMat4 = function (out, a) {
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[4];
                        out[4] = a[5];
                        out[5] = a[6];
                        out[6] = a[8];
                        out[7] = a[9];
                        out[8] = a[10];
                        return out;
                    };

                    /**
                     * Creates a new mat3 initialized with values from an existing matrix
                     *
                     * @param {mat3} a matrix to clone
                     * @returns {mat3} a new 3x3 matrix
                     */
                    mat3.clone = function (a) {
                        var out = new GLMAT_ARRAY_TYPE(9);
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        out[4] = a[4];
                        out[5] = a[5];
                        out[6] = a[6];
                        out[7] = a[7];
                        out[8] = a[8];
                        return out;
                    };

                    /**
                     * Copy the values from one mat3 to another
                     *
                     * @param {mat3} out the receiving matrix
                     * @param {mat3} a the source matrix
                     * @returns {mat3} out
                     */
                    mat3.copy = function (out, a) {
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        out[4] = a[4];
                        out[5] = a[5];
                        out[6] = a[6];
                        out[7] = a[7];
                        out[8] = a[8];
                        return out;
                    };

                    /**
                     * Set a mat3 to the identity matrix
                     *
                     * @param {mat3} out the receiving matrix
                     * @returns {mat3} out
                     */
                    mat3.identity = function (out) {
                        out[0] = 1;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        out[4] = 1;
                        out[5] = 0;
                        out[6] = 0;
                        out[7] = 0;
                        out[8] = 1;
                        return out;
                    };

                    /**
                     * Transpose the values of a mat3
                     *
                     * @param {mat3} out the receiving matrix
                     * @param {mat3} a the source matrix
                     * @returns {mat3} out
                     */
                    mat3.transpose = function (out, a) {
                        // If we are transposing ourselves we can skip a few steps but have to cache some values
                        if (out === a) {
                            var a01 = a[1], a02 = a[2], a12 = a[5];
                            out[1] = a[3];
                            out[2] = a[6];
                            out[3] = a01;
                            out[5] = a[7];
                            out[6] = a02;
                            out[7] = a12;
                        } else {
                            out[0] = a[0];
                            out[1] = a[3];
                            out[2] = a[6];
                            out[3] = a[1];
                            out[4] = a[4];
                            out[5] = a[7];
                            out[6] = a[2];
                            out[7] = a[5];
                            out[8] = a[8];
                        }

                        return out;
                    };

                    /**
                     * Inverts a mat3
                     *
                     * @param {mat3} out the receiving matrix
                     * @param {mat3} a the source matrix
                     * @returns {mat3} out
                     */
                    mat3.invert = function (out, a) {
                        var a00 = a[0], a01 = a[1], a02 = a[2],
                            a10 = a[3], a11 = a[4], a12 = a[5],
                            a20 = a[6], a21 = a[7], a22 = a[8],

                            b01 = a22 * a11 - a12 * a21,
                            b11 = -a22 * a10 + a12 * a20,
                            b21 = a21 * a10 - a11 * a20,

                            // Calculate the determinant
                            det = a00 * b01 + a01 * b11 + a02 * b21;

                        if (!det) {
                            return null;
                        }
                        det = 1.0 / det;

                        out[0] = b01 * det;
                        out[1] = (-a22 * a01 + a02 * a21) * det;
                        out[2] = (a12 * a01 - a02 * a11) * det;
                        out[3] = b11 * det;
                        out[4] = (a22 * a00 - a02 * a20) * det;
                        out[5] = (-a12 * a00 + a02 * a10) * det;
                        out[6] = b21 * det;
                        out[7] = (-a21 * a00 + a01 * a20) * det;
                        out[8] = (a11 * a00 - a01 * a10) * det;
                        return out;
                    };

                    /**
                     * Calculates the adjugate of a mat3
                     *
                     * @param {mat3} out the receiving matrix
                     * @param {mat3} a the source matrix
                     * @returns {mat3} out
                     */
                    mat3.adjoint = function (out, a) {
                        var a00 = a[0], a01 = a[1], a02 = a[2],
                            a10 = a[3], a11 = a[4], a12 = a[5],
                            a20 = a[6], a21 = a[7], a22 = a[8];

                        out[0] = (a11 * a22 - a12 * a21);
                        out[1] = (a02 * a21 - a01 * a22);
                        out[2] = (a01 * a12 - a02 * a11);
                        out[3] = (a12 * a20 - a10 * a22);
                        out[4] = (a00 * a22 - a02 * a20);
                        out[5] = (a02 * a10 - a00 * a12);
                        out[6] = (a10 * a21 - a11 * a20);
                        out[7] = (a01 * a20 - a00 * a21);
                        out[8] = (a00 * a11 - a01 * a10);
                        return out;
                    };

                    /**
                     * Calculates the determinant of a mat3
                     *
                     * @param {mat3} a the source matrix
                     * @returns {Number} determinant of a
                     */
                    mat3.determinant = function (a) {
                        var a00 = a[0], a01 = a[1], a02 = a[2],
                            a10 = a[3], a11 = a[4], a12 = a[5],
                            a20 = a[6], a21 = a[7], a22 = a[8];

                        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
                    };

                    /**
                     * Multiplies two mat3's
                     *
                     * @param {mat3} out the receiving matrix
                     * @param {mat3} a the first operand
                     * @param {mat3} b the second operand
                     * @returns {mat3} out
                     */
                    mat3.multiply = function (out, a, b) {
                        var a00 = a[0], a01 = a[1], a02 = a[2],
                            a10 = a[3], a11 = a[4], a12 = a[5],
                            a20 = a[6], a21 = a[7], a22 = a[8],

                            b00 = b[0], b01 = b[1], b02 = b[2],
                            b10 = b[3], b11 = b[4], b12 = b[5],
                            b20 = b[6], b21 = b[7], b22 = b[8];

                        out[0] = b00 * a00 + b01 * a10 + b02 * a20;
                        out[1] = b00 * a01 + b01 * a11 + b02 * a21;
                        out[2] = b00 * a02 + b01 * a12 + b02 * a22;

                        out[3] = b10 * a00 + b11 * a10 + b12 * a20;
                        out[4] = b10 * a01 + b11 * a11 + b12 * a21;
                        out[5] = b10 * a02 + b11 * a12 + b12 * a22;

                        out[6] = b20 * a00 + b21 * a10 + b22 * a20;
                        out[7] = b20 * a01 + b21 * a11 + b22 * a21;
                        out[8] = b20 * a02 + b21 * a12 + b22 * a22;
                        return out;
                    };

                    /**
                     * Alias for {@link mat3.multiply}
                     * @function
                     */
                    mat3.mul = mat3.multiply;

                    /**
                     * Translate a mat3 by the given vector
                     *
                     * @param {mat3} out the receiving matrix
                     * @param {mat3} a the matrix to translate
                     * @param {vec2} v vector to translate by
                     * @returns {mat3} out
                     */
                    mat3.translate = function (out, a, v) {
                        var a00 = a[0], a01 = a[1], a02 = a[2],
                            a10 = a[3], a11 = a[4], a12 = a[5],
                            a20 = a[6], a21 = a[7], a22 = a[8],
                            x = v[0], y = v[1];

                        out[0] = a00;
                        out[1] = a01;
                        out[2] = a02;

                        out[3] = a10;
                        out[4] = a11;
                        out[5] = a12;

                        out[6] = x * a00 + y * a10 + a20;
                        out[7] = x * a01 + y * a11 + a21;
                        out[8] = x * a02 + y * a12 + a22;
                        return out;
                    };

                    /**
                     * Rotates a mat3 by the given angle
                     *
                     * @param {mat3} out the receiving matrix
                     * @param {mat3} a the matrix to rotate
                     * @param {Number} rad the angle to rotate the matrix by
                     * @returns {mat3} out
                     */
                    mat3.rotate = function (out, a, rad) {
                        var a00 = a[0], a01 = a[1], a02 = a[2],
                            a10 = a[3], a11 = a[4], a12 = a[5],
                            a20 = a[6], a21 = a[7], a22 = a[8],

                            s = Math.sin(rad),
                            c = Math.cos(rad);

                        out[0] = c * a00 + s * a10;
                        out[1] = c * a01 + s * a11;
                        out[2] = c * a02 + s * a12;

                        out[3] = c * a10 - s * a00;
                        out[4] = c * a11 - s * a01;
                        out[5] = c * a12 - s * a02;

                        out[6] = a20;
                        out[7] = a21;
                        out[8] = a22;
                        return out;
                    };

                    /**
                     * Scales the mat3 by the dimensions in the given vec2
                     *
                     * @param {mat3} out the receiving matrix
                     * @param {mat3} a the matrix to rotate
                     * @param {vec2} v the vec2 to scale the matrix by
                     * @returns {mat3} out
                     **/
                    mat3.scale = function (out, a, v) {
                        var x = v[0], y = v[1];

                        out[0] = x * a[0];
                        out[1] = x * a[1];
                        out[2] = x * a[2];

                        out[3] = y * a[3];
                        out[4] = y * a[4];
                        out[5] = y * a[5];

                        out[6] = a[6];
                        out[7] = a[7];
                        out[8] = a[8];
                        return out;
                    };

                    /**
                     * Copies the values from a mat2d into a mat3
                     *
                     * @param {mat3} out the receiving matrix
                     * @param {mat2d} a the matrix to copy
                     * @returns {mat3} out
                     **/
                    mat3.fromMat2d = function (out, a) {
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = 0;

                        out[3] = a[2];
                        out[4] = a[3];
                        out[5] = 0;

                        out[6] = a[4];
                        out[7] = a[5];
                        out[8] = 1;
                        return out;
                    };

                    /**
                    * Calculates a 3x3 matrix from the given quaternion
                    *
                    * @param {mat3} out mat3 receiving operation result
                    * @param {quat} q Quaternion to create matrix from
                    *
                    * @returns {mat3} out
                    */
                    mat3.fromQuat = function (out, q) {
                        var x = q[0], y = q[1], z = q[2], w = q[3],
                            x2 = x + x,
                            y2 = y + y,
                            z2 = z + z,

                            xx = x * x2,
                            yx = y * x2,
                            yy = y * y2,
                            zx = z * x2,
                            zy = z * y2,
                            zz = z * z2,
                            wx = w * x2,
                            wy = w * y2,
                            wz = w * z2;

                        out[0] = 1 - yy - zz;
                        out[3] = yx - wz;
                        out[6] = zx + wy;

                        out[1] = yx + wz;
                        out[4] = 1 - xx - zz;
                        out[7] = zy - wx;

                        out[2] = zx - wy;
                        out[5] = zy + wx;
                        out[8] = 1 - xx - yy;

                        return out;
                    };

                    /**
                    * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
                    *
                    * @param {mat3} out mat3 receiving operation result
                    * @param {mat4} a Mat4 to derive the normal matrix from
                    *
                    * @returns {mat3} out
                    */
                    mat3.normalFromMat4 = function (out, a) {
                        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

                            b00 = a00 * a11 - a01 * a10,
                            b01 = a00 * a12 - a02 * a10,
                            b02 = a00 * a13 - a03 * a10,
                            b03 = a01 * a12 - a02 * a11,
                            b04 = a01 * a13 - a03 * a11,
                            b05 = a02 * a13 - a03 * a12,
                            b06 = a20 * a31 - a21 * a30,
                            b07 = a20 * a32 - a22 * a30,
                            b08 = a20 * a33 - a23 * a30,
                            b09 = a21 * a32 - a22 * a31,
                            b10 = a21 * a33 - a23 * a31,
                            b11 = a22 * a33 - a23 * a32,

                            // Calculate the determinant
                            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                        if (!det) {
                            return null;
                        }
                        det = 1.0 / det;

                        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

                        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

                        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

                        return out;
                    };

                    /**
                     * Returns a string representation of a mat3
                     *
                     * @param {mat3} mat matrix to represent as a string
                     * @returns {String} string representation of the matrix
                     */
                    mat3.str = function (a) {
                        return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
                                        a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
                                        a[6] + ', ' + a[7] + ', ' + a[8] + ')';
                    };

                    /**
                     * Returns Frobenius norm of a mat3
                     *
                     * @param {mat3} a the matrix to calculate Frobenius norm of
                     * @returns {Number} Frobenius norm
                     */
                    mat3.frob = function (a) {
                        return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
                    };


                    if (typeof (exports) !== 'undefined') {
                        exports.mat3 = mat3;
                    }
                    ;
                    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
                    
                    Redistribution and use in source and binary forms, with or without modification,
                    are permitted provided that the following conditions are met:
                    
                      * Redistributions of source code must retain the above copyright notice, this
                        list of conditions and the following disclaimer.
                      * Redistributions in binary form must reproduce the above copyright notice,
                        this list of conditions and the following disclaimer in the documentation 
                        and/or other materials provided with the distribution.
                    
                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
                    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
                    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
                    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

                    /**
                     * @class 4x4 Matrix
                     * @name mat4
                     */

                    var mat4 = {};

                    /**
                     * Creates a new identity mat4
                     *
                     * @returns {mat4} a new 4x4 matrix
                     */
                    mat4.create = function () {
                        var out = new GLMAT_ARRAY_TYPE(16);
                        out[0] = 1;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        out[4] = 0;
                        out[5] = 1;
                        out[6] = 0;
                        out[7] = 0;
                        out[8] = 0;
                        out[9] = 0;
                        out[10] = 1;
                        out[11] = 0;
                        out[12] = 0;
                        out[13] = 0;
                        out[14] = 0;
                        out[15] = 1;
                        return out;
                    };

                    /**
                     * Creates a new mat4 initialized with values from an existing matrix
                     *
                     * @param {mat4} a matrix to clone
                     * @returns {mat4} a new 4x4 matrix
                     */
                    mat4.clone = function (a) {
                        var out = new GLMAT_ARRAY_TYPE(16);
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        out[4] = a[4];
                        out[5] = a[5];
                        out[6] = a[6];
                        out[7] = a[7];
                        out[8] = a[8];
                        out[9] = a[9];
                        out[10] = a[10];
                        out[11] = a[11];
                        out[12] = a[12];
                        out[13] = a[13];
                        out[14] = a[14];
                        out[15] = a[15];
                        return out;
                    };

                    /**
                     * Copy the values from one mat4 to another
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the source matrix
                     * @returns {mat4} out
                     */
                    mat4.copy = function (out, a) {
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        out[4] = a[4];
                        out[5] = a[5];
                        out[6] = a[6];
                        out[7] = a[7];
                        out[8] = a[8];
                        out[9] = a[9];
                        out[10] = a[10];
                        out[11] = a[11];
                        out[12] = a[12];
                        out[13] = a[13];
                        out[14] = a[14];
                        out[15] = a[15];
                        return out;
                    };

                    /**
                     * Set a mat4 to the identity matrix
                     *
                     * @param {mat4} out the receiving matrix
                     * @returns {mat4} out
                     */
                    mat4.identity = function (out) {
                        out[0] = 1;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        out[4] = 0;
                        out[5] = 1;
                        out[6] = 0;
                        out[7] = 0;
                        out[8] = 0;
                        out[9] = 0;
                        out[10] = 1;
                        out[11] = 0;
                        out[12] = 0;
                        out[13] = 0;
                        out[14] = 0;
                        out[15] = 1;
                        return out;
                    };

                    /**
                     * Transpose the values of a mat4
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the source matrix
                     * @returns {mat4} out
                     */
                    mat4.transpose = function (out, a) {
                        // If we are transposing ourselves we can skip a few steps but have to cache some values
                        if (out === a) {
                            var a01 = a[1], a02 = a[2], a03 = a[3],
                                a12 = a[6], a13 = a[7],
                                a23 = a[11];

                            out[1] = a[4];
                            out[2] = a[8];
                            out[3] = a[12];
                            out[4] = a01;
                            out[6] = a[9];
                            out[7] = a[13];
                            out[8] = a02;
                            out[9] = a12;
                            out[11] = a[14];
                            out[12] = a03;
                            out[13] = a13;
                            out[14] = a23;
                        } else {
                            out[0] = a[0];
                            out[1] = a[4];
                            out[2] = a[8];
                            out[3] = a[12];
                            out[4] = a[1];
                            out[5] = a[5];
                            out[6] = a[9];
                            out[7] = a[13];
                            out[8] = a[2];
                            out[9] = a[6];
                            out[10] = a[10];
                            out[11] = a[14];
                            out[12] = a[3];
                            out[13] = a[7];
                            out[14] = a[11];
                            out[15] = a[15];
                        }

                        return out;
                    };

                    /**
                     * Inverts a mat4
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the source matrix
                     * @returns {mat4} out
                     */
                    mat4.invert = function (out, a) {
                        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

                            b00 = a00 * a11 - a01 * a10,
                            b01 = a00 * a12 - a02 * a10,
                            b02 = a00 * a13 - a03 * a10,
                            b03 = a01 * a12 - a02 * a11,
                            b04 = a01 * a13 - a03 * a11,
                            b05 = a02 * a13 - a03 * a12,
                            b06 = a20 * a31 - a21 * a30,
                            b07 = a20 * a32 - a22 * a30,
                            b08 = a20 * a33 - a23 * a30,
                            b09 = a21 * a32 - a22 * a31,
                            b10 = a21 * a33 - a23 * a31,
                            b11 = a22 * a33 - a23 * a32,

                            // Calculate the determinant
                            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                        if (!det) {
                            return null;
                        }
                        det = 1.0 / det;

                        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

                        return out;
                    };

                    /**
                     * Calculates the adjugate of a mat4
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the source matrix
                     * @returns {mat4} out
                     */
                    mat4.adjoint = function (out, a) {
                        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

                        out[0] = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
                        out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
                        out[2] = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
                        out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
                        out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
                        out[5] = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
                        out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
                        out[7] = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
                        out[8] = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
                        out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
                        out[10] = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
                        out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
                        out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
                        out[13] = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
                        out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
                        out[15] = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
                        return out;
                    };

                    /**
                     * Calculates the determinant of a mat4
                     *
                     * @param {mat4} a the source matrix
                     * @returns {Number} determinant of a
                     */
                    mat4.determinant = function (a) {
                        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

                            b00 = a00 * a11 - a01 * a10,
                            b01 = a00 * a12 - a02 * a10,
                            b02 = a00 * a13 - a03 * a10,
                            b03 = a01 * a12 - a02 * a11,
                            b04 = a01 * a13 - a03 * a11,
                            b05 = a02 * a13 - a03 * a12,
                            b06 = a20 * a31 - a21 * a30,
                            b07 = a20 * a32 - a22 * a30,
                            b08 = a20 * a33 - a23 * a30,
                            b09 = a21 * a32 - a22 * a31,
                            b10 = a21 * a33 - a23 * a31,
                            b11 = a22 * a33 - a23 * a32;

                        // Calculate the determinant
                        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                    };

                    /**
                     * Multiplies two mat4's
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the first operand
                     * @param {mat4} b the second operand
                     * @returns {mat4} out
                     */
                    mat4.multiply = function (out, a, b) {
                        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                            a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                            a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                            a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

                        // Cache only the current line of the second matrix
                        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                        b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                        b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                        b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                        return out;
                    };

                    /**
                     * Alias for {@link mat4.multiply}
                     * @function
                     */
                    mat4.mul = mat4.multiply;

                    /**
                     * Translate a mat4 by the given vector
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the matrix to translate
                     * @param {vec3} v vector to translate by
                     * @returns {mat4} out
                     */
                    mat4.translate = function (out, a, v) {
                        var x = v[0], y = v[1], z = v[2],
                            a00, a01, a02, a03,
                            a10, a11, a12, a13,
                            a20, a21, a22, a23;

                        if (a === out) {
                            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                        } else {
                            a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                            a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                            a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

                            out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                            out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                            out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

                            out[12] = a00 * x + a10 * y + a20 * z + a[12];
                            out[13] = a01 * x + a11 * y + a21 * z + a[13];
                            out[14] = a02 * x + a12 * y + a22 * z + a[14];
                            out[15] = a03 * x + a13 * y + a23 * z + a[15];
                        }

                        return out;
                    };

                    /**
                     * Scales the mat4 by the dimensions in the given vec3
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the matrix to scale
                     * @param {vec3} v the vec3 to scale the matrix by
                     * @returns {mat4} out
                     **/
                    mat4.scale = function (out, a, v) {
                        var x = v[0], y = v[1], z = v[2];

                        out[0] = a[0] * x;
                        out[1] = a[1] * x;
                        out[2] = a[2] * x;
                        out[3] = a[3] * x;
                        out[4] = a[4] * y;
                        out[5] = a[5] * y;
                        out[6] = a[6] * y;
                        out[7] = a[7] * y;
                        out[8] = a[8] * z;
                        out[9] = a[9] * z;
                        out[10] = a[10] * z;
                        out[11] = a[11] * z;
                        out[12] = a[12];
                        out[13] = a[13];
                        out[14] = a[14];
                        out[15] = a[15];
                        return out;
                    };

                    /**
                     * Rotates a mat4 by the given angle
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the matrix to rotate
                     * @param {Number} rad the angle to rotate the matrix by
                     * @param {vec3} axis the axis to rotate around
                     * @returns {mat4} out
                     */
                    mat4.rotate = function (out, a, rad, axis) {
                        var x = axis[0], y = axis[1], z = axis[2],
                            len = Math.sqrt(x * x + y * y + z * z),
                            s, c, t,
                            a00, a01, a02, a03,
                            a10, a11, a12, a13,
                            a20, a21, a22, a23,
                            b00, b01, b02,
                            b10, b11, b12,
                            b20, b21, b22;

                        if (Math.abs(len) < GLMAT_EPSILON) { return null; }

                        len = 1 / len;
                        x *= len;
                        y *= len;
                        z *= len;

                        s = Math.sin(rad);
                        c = Math.cos(rad);
                        t = 1 - c;

                        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

                        // Construct the elements of the rotation matrix
                        b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
                        b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
                        b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

                        // Perform rotation-specific matrix multiplication
                        out[0] = a00 * b00 + a10 * b01 + a20 * b02;
                        out[1] = a01 * b00 + a11 * b01 + a21 * b02;
                        out[2] = a02 * b00 + a12 * b01 + a22 * b02;
                        out[3] = a03 * b00 + a13 * b01 + a23 * b02;
                        out[4] = a00 * b10 + a10 * b11 + a20 * b12;
                        out[5] = a01 * b10 + a11 * b11 + a21 * b12;
                        out[6] = a02 * b10 + a12 * b11 + a22 * b12;
                        out[7] = a03 * b10 + a13 * b11 + a23 * b12;
                        out[8] = a00 * b20 + a10 * b21 + a20 * b22;
                        out[9] = a01 * b20 + a11 * b21 + a21 * b22;
                        out[10] = a02 * b20 + a12 * b21 + a22 * b22;
                        out[11] = a03 * b20 + a13 * b21 + a23 * b22;

                        if (a !== out) { // If the source and destination differ, copy the unchanged last row
                            out[12] = a[12];
                            out[13] = a[13];
                            out[14] = a[14];
                            out[15] = a[15];
                        }
                        return out;
                    };

                    /**
                     * Rotates a matrix by the given angle around the X axis
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the matrix to rotate
                     * @param {Number} rad the angle to rotate the matrix by
                     * @returns {mat4} out
                     */
                    mat4.rotateX = function (out, a, rad) {
                        var s = Math.sin(rad),
                            c = Math.cos(rad),
                            a10 = a[4],
                            a11 = a[5],
                            a12 = a[6],
                            a13 = a[7],
                            a20 = a[8],
                            a21 = a[9],
                            a22 = a[10],
                            a23 = a[11];

                        if (a !== out) { // If the source and destination differ, copy the unchanged rows
                            out[0] = a[0];
                            out[1] = a[1];
                            out[2] = a[2];
                            out[3] = a[3];
                            out[12] = a[12];
                            out[13] = a[13];
                            out[14] = a[14];
                            out[15] = a[15];
                        }

                        // Perform axis-specific matrix multiplication
                        out[4] = a10 * c + a20 * s;
                        out[5] = a11 * c + a21 * s;
                        out[6] = a12 * c + a22 * s;
                        out[7] = a13 * c + a23 * s;
                        out[8] = a20 * c - a10 * s;
                        out[9] = a21 * c - a11 * s;
                        out[10] = a22 * c - a12 * s;
                        out[11] = a23 * c - a13 * s;
                        return out;
                    };

                    /**
                     * Rotates a matrix by the given angle around the Y axis
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the matrix to rotate
                     * @param {Number} rad the angle to rotate the matrix by
                     * @returns {mat4} out
                     */
                    mat4.rotateY = function (out, a, rad) {
                        var s = Math.sin(rad),
                            c = Math.cos(rad),
                            a00 = a[0],
                            a01 = a[1],
                            a02 = a[2],
                            a03 = a[3],
                            a20 = a[8],
                            a21 = a[9],
                            a22 = a[10],
                            a23 = a[11];

                        if (a !== out) { // If the source and destination differ, copy the unchanged rows
                            out[4] = a[4];
                            out[5] = a[5];
                            out[6] = a[6];
                            out[7] = a[7];
                            out[12] = a[12];
                            out[13] = a[13];
                            out[14] = a[14];
                            out[15] = a[15];
                        }

                        // Perform axis-specific matrix multiplication
                        out[0] = a00 * c - a20 * s;
                        out[1] = a01 * c - a21 * s;
                        out[2] = a02 * c - a22 * s;
                        out[3] = a03 * c - a23 * s;
                        out[8] = a00 * s + a20 * c;
                        out[9] = a01 * s + a21 * c;
                        out[10] = a02 * s + a22 * c;
                        out[11] = a03 * s + a23 * c;
                        return out;
                    };

                    /**
                     * Rotates a matrix by the given angle around the Z axis
                     *
                     * @param {mat4} out the receiving matrix
                     * @param {mat4} a the matrix to rotate
                     * @param {Number} rad the angle to rotate the matrix by
                     * @returns {mat4} out
                     */
                    mat4.rotateZ = function (out, a, rad) {
                        var s = Math.sin(rad),
                            c = Math.cos(rad),
                            a00 = a[0],
                            a01 = a[1],
                            a02 = a[2],
                            a03 = a[3],
                            a10 = a[4],
                            a11 = a[5],
                            a12 = a[6],
                            a13 = a[7];

                        if (a !== out) { // If the source and destination differ, copy the unchanged last row
                            out[8] = a[8];
                            out[9] = a[9];
                            out[10] = a[10];
                            out[11] = a[11];
                            out[12] = a[12];
                            out[13] = a[13];
                            out[14] = a[14];
                            out[15] = a[15];
                        }

                        // Perform axis-specific matrix multiplication
                        out[0] = a00 * c + a10 * s;
                        out[1] = a01 * c + a11 * s;
                        out[2] = a02 * c + a12 * s;
                        out[3] = a03 * c + a13 * s;
                        out[4] = a10 * c - a00 * s;
                        out[5] = a11 * c - a01 * s;
                        out[6] = a12 * c - a02 * s;
                        out[7] = a13 * c - a03 * s;
                        return out;
                    };

                    /**
                     * Creates a matrix from a quaternion rotation and vector translation
                     * This is equivalent to (but much faster than):
                     *
                     *     mat4.identity(dest);
                     *     mat4.translate(dest, vec);
                     *     var quatMat = mat4.create();
                     *     quat4.toMat4(quat, quatMat);
                     *     mat4.multiply(dest, quatMat);
                     *
                     * @param {mat4} out mat4 receiving operation result
                     * @param {quat4} q Rotation quaternion
                     * @param {vec3} v Translation vector
                     * @returns {mat4} out
                     */
                    mat4.fromRotationTranslation = function (out, q, v) {
                        // Quaternion math
                        var x = q[0], y = q[1], z = q[2], w = q[3],
                            x2 = x + x,
                            y2 = y + y,
                            z2 = z + z,

                            xx = x * x2,
                            xy = x * y2,
                            xz = x * z2,
                            yy = y * y2,
                            yz = y * z2,
                            zz = z * z2,
                            wx = w * x2,
                            wy = w * y2,
                            wz = w * z2;

                        out[0] = 1 - (yy + zz);
                        out[1] = xy + wz;
                        out[2] = xz - wy;
                        out[3] = 0;
                        out[4] = xy - wz;
                        out[5] = 1 - (xx + zz);
                        out[6] = yz + wx;
                        out[7] = 0;
                        out[8] = xz + wy;
                        out[9] = yz - wx;
                        out[10] = 1 - (xx + yy);
                        out[11] = 0;
                        out[12] = v[0];
                        out[13] = v[1];
                        out[14] = v[2];
                        out[15] = 1;

                        return out;
                    };

                    mat4.fromQuat = function (out, q) {
                        var x = q[0], y = q[1], z = q[2], w = q[3],
                            x2 = x + x,
                            y2 = y + y,
                            z2 = z + z,

                            xx = x * x2,
                            yx = y * x2,
                            yy = y * y2,
                            zx = z * x2,
                            zy = z * y2,
                            zz = z * z2,
                            wx = w * x2,
                            wy = w * y2,
                            wz = w * z2;

                        out[0] = 1 - yy - zz;
                        out[1] = yx + wz;
                        out[2] = zx - wy;
                        out[3] = 0;

                        out[4] = yx - wz;
                        out[5] = 1 - xx - zz;
                        out[6] = zy + wx;
                        out[7] = 0;

                        out[8] = zx + wy;
                        out[9] = zy - wx;
                        out[10] = 1 - xx - yy;
                        out[11] = 0;

                        out[12] = 0;
                        out[13] = 0;
                        out[14] = 0;
                        out[15] = 1;

                        return out;
                    };

                    /**
                     * Generates a frustum matrix with the given bounds
                     *
                     * @param {mat4} out mat4 frustum matrix will be written into
                     * @param {Number} left Left bound of the frustum
                     * @param {Number} right Right bound of the frustum
                     * @param {Number} bottom Bottom bound of the frustum
                     * @param {Number} top Top bound of the frustum
                     * @param {Number} near Near bound of the frustum
                     * @param {Number} far Far bound of the frustum
                     * @returns {mat4} out
                     */
                    mat4.frustum = function (out, left, right, bottom, top, near, far) {
                        var rl = 1 / (right - left),
                            tb = 1 / (top - bottom),
                            nf = 1 / (near - far);
                        out[0] = (near * 2) * rl;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        out[4] = 0;
                        out[5] = (near * 2) * tb;
                        out[6] = 0;
                        out[7] = 0;
                        out[8] = (right + left) * rl;
                        out[9] = (top + bottom) * tb;
                        out[10] = (far + near) * nf;
                        out[11] = -1;
                        out[12] = 0;
                        out[13] = 0;
                        out[14] = (far * near * 2) * nf;
                        out[15] = 0;
                        return out;
                    };

                    /**
                     * Generates a perspective projection matrix with the given bounds
                     *
                     * @param {mat4} out mat4 frustum matrix will be written into
                     * @param {number} fovy Vertical field of view in radians
                     * @param {number} aspect Aspect ratio. typically viewport width/height
                     * @param {number} near Near bound of the frustum
                     * @param {number} far Far bound of the frustum
                     * @returns {mat4} out
                     */
                    mat4.perspective = function (out, fovy, aspect, near, far) {
                        var f = 1.0 / Math.tan(fovy / 2),
                            nf = 1 / (near - far);
                        out[0] = f / aspect;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        out[4] = 0;
                        out[5] = f;
                        out[6] = 0;
                        out[7] = 0;
                        out[8] = 0;
                        out[9] = 0;
                        out[10] = (far + near) * nf;
                        out[11] = -1;
                        out[12] = 0;
                        out[13] = 0;
                        out[14] = (2 * far * near) * nf;
                        out[15] = 0;
                        return out;
                    };

                    /**
                     * Generates a orthogonal projection matrix with the given bounds
                     *
                     * @param {mat4} out mat4 frustum matrix will be written into
                     * @param {number} left Left bound of the frustum
                     * @param {number} right Right bound of the frustum
                     * @param {number} bottom Bottom bound of the frustum
                     * @param {number} top Top bound of the frustum
                     * @param {number} near Near bound of the frustum
                     * @param {number} far Far bound of the frustum
                     * @returns {mat4} out
                     */
                    mat4.ortho = function (out, left, right, bottom, top, near, far) {
                        var lr = 1 / (left - right),
                            bt = 1 / (bottom - top),
                            nf = 1 / (near - far);
                        out[0] = -2 * lr;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        out[4] = 0;
                        out[5] = -2 * bt;
                        out[6] = 0;
                        out[7] = 0;
                        out[8] = 0;
                        out[9] = 0;
                        out[10] = 2 * nf;
                        out[11] = 0;
                        out[12] = (left + right) * lr;
                        out[13] = (top + bottom) * bt;
                        out[14] = (far + near) * nf;
                        out[15] = 1;
                        return out;
                    };

                    /**
                     * Generates a look-at matrix with the given eye position, focal point, and up axis
                     *
                     * @param {mat4} out mat4 frustum matrix will be written into
                     * @param {vec3} eye Position of the viewer
                     * @param {vec3} center Point the viewer is looking at
                     * @param {vec3} up vec3 pointing up
                     * @returns {mat4} out
                     */
                    mat4.lookAt = function (out, eye, center, up) {
                        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
                            eyex = eye[0],
                            eyey = eye[1],
                            eyez = eye[2],
                            upx = up[0],
                            upy = up[1],
                            upz = up[2],
                            centerx = center[0],
                            centery = center[1],
                            centerz = center[2];

                        if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
                            Math.abs(eyey - centery) < GLMAT_EPSILON &&
                            Math.abs(eyez - centerz) < GLMAT_EPSILON) {
                            return mat4.identity(out);
                        }

                        z0 = eyex - centerx;
                        z1 = eyey - centery;
                        z2 = eyez - centerz;

                        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                        z0 *= len;
                        z1 *= len;
                        z2 *= len;

                        x0 = upy * z2 - upz * z1;
                        x1 = upz * z0 - upx * z2;
                        x2 = upx * z1 - upy * z0;
                        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                        if (!len) {
                            x0 = 0;
                            x1 = 0;
                            x2 = 0;
                        } else {
                            len = 1 / len;
                            x0 *= len;
                            x1 *= len;
                            x2 *= len;
                        }

                        y0 = z1 * x2 - z2 * x1;
                        y1 = z2 * x0 - z0 * x2;
                        y2 = z0 * x1 - z1 * x0;

                        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
                        if (!len) {
                            y0 = 0;
                            y1 = 0;
                            y2 = 0;
                        } else {
                            len = 1 / len;
                            y0 *= len;
                            y1 *= len;
                            y2 *= len;
                        }

                        out[0] = x0;
                        out[1] = y0;
                        out[2] = z0;
                        out[3] = 0;
                        out[4] = x1;
                        out[5] = y1;
                        out[6] = z1;
                        out[7] = 0;
                        out[8] = x2;
                        out[9] = y2;
                        out[10] = z2;
                        out[11] = 0;
                        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                        out[15] = 1;

                        return out;
                    };

                    /**
                     * Returns a string representation of a mat4
                     *
                     * @param {mat4} mat matrix to represent as a string
                     * @returns {String} string representation of the matrix
                     */
                    mat4.str = function (a) {
                        return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                                        a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                                        a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                                        a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
                    };

                    /**
                     * Returns Frobenius norm of a mat4
                     *
                     * @param {mat4} a the matrix to calculate Frobenius norm of
                     * @returns {Number} Frobenius norm
                     */
                    mat4.frob = function (a) {
                        return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2)))
                    };


                    if (typeof (exports) !== 'undefined') {
                        exports.mat4 = mat4;
                    }
                    ;
                    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.
                    
                    Redistribution and use in source and binary forms, with or without modification,
                    are permitted provided that the following conditions are met:
                    
                      * Redistributions of source code must retain the above copyright notice, this
                        list of conditions and the following disclaimer.
                      * Redistributions in binary form must reproduce the above copyright notice,
                        this list of conditions and the following disclaimer in the documentation 
                        and/or other materials provided with the distribution.
                    
                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
                    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
                    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
                    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
                    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
                    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
                    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

                    /**
                     * @class Quaternion
                     * @name quat
                     */

                    var quat = {};

                    /**
                     * Creates a new identity quat
                     *
                     * @returns {quat} a new quaternion
                     */
                    quat.create = function () {
                        var out = new GLMAT_ARRAY_TYPE(4);
                        out[0] = 0;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 1;
                        return out;
                    };

                    /**
                     * Sets a quaternion to represent the shortest rotation from one
                     * vector to another.
                     *
                     * Both vectors are assumed to be unit length.
                     *
                     * @param {quat} out the receiving quaternion.
                     * @param {vec3} a the initial vector
                     * @param {vec3} b the destination vector
                     * @returns {quat} out
                     */
                    quat.rotationTo = (function () {
                        var tmpvec3 = vec3.create();
                        var xUnitVec3 = vec3.fromValues(1, 0, 0);
                        var yUnitVec3 = vec3.fromValues(0, 1, 0);

                        return function (out, a, b) {
                            var dot = vec3.dot(a, b);
                            if (dot < -0.999999) {
                                vec3.cross(tmpvec3, xUnitVec3, a);
                                if (vec3.length(tmpvec3) < 0.000001)
                                    vec3.cross(tmpvec3, yUnitVec3, a);
                                vec3.normalize(tmpvec3, tmpvec3);
                                quat.setAxisAngle(out, tmpvec3, Math.PI);
                                return out;
                            } else if (dot > 0.999999) {
                                out[0] = 0;
                                out[1] = 0;
                                out[2] = 0;
                                out[3] = 1;
                                return out;
                            } else {
                                vec3.cross(tmpvec3, a, b);
                                out[0] = tmpvec3[0];
                                out[1] = tmpvec3[1];
                                out[2] = tmpvec3[2];
                                out[3] = 1 + dot;
                                return quat.normalize(out, out);
                            }
                        };
                    })();

                    /**
                     * Sets the specified quaternion with values corresponding to the given
                     * axes. Each axis is a vec3 and is expected to be unit length and
                     * perpendicular to all other specified axes.
                     *
                     * @param {vec3} view  the vector representing the viewing direction
                     * @param {vec3} right the vector representing the local "right" direction
                     * @param {vec3} up    the vector representing the local "up" direction
                     * @returns {quat} out
                     */
                    quat.setAxes = (function () {
                        var matr = mat3.create();

                        return function (out, view, right, up) {
                            matr[0] = right[0];
                            matr[3] = right[1];
                            matr[6] = right[2];

                            matr[1] = up[0];
                            matr[4] = up[1];
                            matr[7] = up[2];

                            matr[2] = -view[0];
                            matr[5] = -view[1];
                            matr[8] = -view[2];

                            return quat.normalize(out, quat.fromMat3(out, matr));
                        };
                    })();

                    /**
                     * Creates a new quat initialized with values from an existing quaternion
                     *
                     * @param {quat} a quaternion to clone
                     * @returns {quat} a new quaternion
                     * @function
                     */
                    quat.clone = vec4.clone;

                    /**
                     * Creates a new quat initialized with the given values
                     *
                     * @param {Number} x X component
                     * @param {Number} y Y component
                     * @param {Number} z Z component
                     * @param {Number} w W component
                     * @returns {quat} a new quaternion
                     * @function
                     */
                    quat.fromValues = vec4.fromValues;

                    /**
                     * Copy the values from one quat to another
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {quat} a the source quaternion
                     * @returns {quat} out
                     * @function
                     */
                    quat.copy = vec4.copy;

                    /**
                     * Set the components of a quat to the given values
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {Number} x X component
                     * @param {Number} y Y component
                     * @param {Number} z Z component
                     * @param {Number} w W component
                     * @returns {quat} out
                     * @function
                     */
                    quat.set = vec4.set;

                    /**
                     * Set a quat to the identity quaternion
                     *
                     * @param {quat} out the receiving quaternion
                     * @returns {quat} out
                     */
                    quat.identity = function (out) {
                        out[0] = 0;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 1;
                        return out;
                    };

                    /**
                     * Sets a quat from the given angle and rotation axis,
                     * then returns it.
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {vec3} axis the axis around which to rotate
                     * @param {Number} rad the angle in radians
                     * @returns {quat} out
                     **/
                    quat.setAxisAngle = function (out, axis, rad) {
                        rad = rad * 0.5;
                        var s = Math.sin(rad);
                        out[0] = s * axis[0];
                        out[1] = s * axis[1];
                        out[2] = s * axis[2];
                        out[3] = Math.cos(rad);
                        return out;
                    };

                    /**
                     * Adds two quat's
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {quat} a the first operand
                     * @param {quat} b the second operand
                     * @returns {quat} out
                     * @function
                     */
                    quat.add = vec4.add;

                    /**
                     * Multiplies two quat's
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {quat} a the first operand
                     * @param {quat} b the second operand
                     * @returns {quat} out
                     */
                    quat.multiply = function (out, a, b) {
                        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                            bx = b[0], by = b[1], bz = b[2], bw = b[3];

                        out[0] = ax * bw + aw * bx + ay * bz - az * by;
                        out[1] = ay * bw + aw * by + az * bx - ax * bz;
                        out[2] = az * bw + aw * bz + ax * by - ay * bx;
                        out[3] = aw * bw - ax * bx - ay * by - az * bz;
                        return out;
                    };

                    /**
                     * Alias for {@link quat.multiply}
                     * @function
                     */
                    quat.mul = quat.multiply;

                    /**
                     * Scales a quat by a scalar number
                     *
                     * @param {quat} out the receiving vector
                     * @param {quat} a the vector to scale
                     * @param {Number} b amount to scale the vector by
                     * @returns {quat} out
                     * @function
                     */
                    quat.scale = vec4.scale;

                    /**
                     * Rotates a quaternion by the given angle about the X axis
                     *
                     * @param {quat} out quat receiving operation result
                     * @param {quat} a quat to rotate
                     * @param {number} rad angle (in radians) to rotate
                     * @returns {quat} out
                     */
                    quat.rotateX = function (out, a, rad) {
                        rad *= 0.5;

                        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                            bx = Math.sin(rad), bw = Math.cos(rad);

                        out[0] = ax * bw + aw * bx;
                        out[1] = ay * bw + az * bx;
                        out[2] = az * bw - ay * bx;
                        out[3] = aw * bw - ax * bx;
                        return out;
                    };

                    /**
                     * Rotates a quaternion by the given angle about the Y axis
                     *
                     * @param {quat} out quat receiving operation result
                     * @param {quat} a quat to rotate
                     * @param {number} rad angle (in radians) to rotate
                     * @returns {quat} out
                     */
                    quat.rotateY = function (out, a, rad) {
                        rad *= 0.5;

                        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                            by = Math.sin(rad), bw = Math.cos(rad);

                        out[0] = ax * bw - az * by;
                        out[1] = ay * bw + aw * by;
                        out[2] = az * bw + ax * by;
                        out[3] = aw * bw - ay * by;
                        return out;
                    };

                    /**
                     * Rotates a quaternion by the given angle about the Z axis
                     *
                     * @param {quat} out quat receiving operation result
                     * @param {quat} a quat to rotate
                     * @param {number} rad angle (in radians) to rotate
                     * @returns {quat} out
                     */
                    quat.rotateZ = function (out, a, rad) {
                        rad *= 0.5;

                        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                            bz = Math.sin(rad), bw = Math.cos(rad);

                        out[0] = ax * bw + ay * bz;
                        out[1] = ay * bw - ax * bz;
                        out[2] = az * bw + aw * bz;
                        out[3] = aw * bw - az * bz;
                        return out;
                    };

                    /**
                     * Calculates the W component of a quat from the X, Y, and Z components.
                     * Assumes that quaternion is 1 unit in length.
                     * Any existing W component will be ignored.
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {quat} a quat to calculate W component of
                     * @returns {quat} out
                     */
                    quat.calculateW = function (out, a) {
                        var x = a[0], y = a[1], z = a[2];

                        out[0] = x;
                        out[1] = y;
                        out[2] = z;
                        out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
                        return out;
                    };

                    /**
                     * Calculates the dot product of two quat's
                     *
                     * @param {quat} a the first operand
                     * @param {quat} b the second operand
                     * @returns {Number} dot product of a and b
                     * @function
                     */
                    quat.dot = vec4.dot;

                    /**
                     * Performs a linear interpolation between two quat's
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {quat} a the first operand
                     * @param {quat} b the second operand
                     * @param {Number} t interpolation amount between the two inputs
                     * @returns {quat} out
                     * @function
                     */
                    quat.lerp = vec4.lerp;

                    /**
                     * Performs a spherical linear interpolation between two quat
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {quat} a the first operand
                     * @param {quat} b the second operand
                     * @param {Number} t interpolation amount between the two inputs
                     * @returns {quat} out
                     */
                    quat.slerp = function (out, a, b, t) {
                        // benchmarks:
                        //    http://jsperf.com/quaternion-slerp-implementations

                        var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                            bx = b[0], by = b[1], bz = b[2], bw = b[3];

                        var omega, cosom, sinom, scale0, scale1;

                        // calc cosine
                        cosom = ax * bx + ay * by + az * bz + aw * bw;
                        // adjust signs (if necessary)
                        if (cosom < 0.0) {
                            cosom = -cosom;
                            bx = -bx;
                            by = -by;
                            bz = -bz;
                            bw = -bw;
                        }
                        // calculate coefficients
                        if ((1.0 - cosom) > 0.000001) {
                            // standard case (slerp)
                            omega = Math.acos(cosom);
                            sinom = Math.sin(omega);
                            scale0 = Math.sin((1.0 - t) * omega) / sinom;
                            scale1 = Math.sin(t * omega) / sinom;
                        } else {
                            // "from" and "to" quaternions are very close 
                            //  ... so we can do a linear interpolation
                            scale0 = 1.0 - t;
                            scale1 = t;
                        }
                        // calculate final values
                        out[0] = scale0 * ax + scale1 * bx;
                        out[1] = scale0 * ay + scale1 * by;
                        out[2] = scale0 * az + scale1 * bz;
                        out[3] = scale0 * aw + scale1 * bw;

                        return out;
                    };

                    /**
                     * Calculates the inverse of a quat
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {quat} a quat to calculate inverse of
                     * @returns {quat} out
                     */
                    quat.invert = function (out, a) {
                        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
                            dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3,
                            invDot = dot ? 1.0 / dot : 0;

                        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

                        out[0] = -a0 * invDot;
                        out[1] = -a1 * invDot;
                        out[2] = -a2 * invDot;
                        out[3] = a3 * invDot;
                        return out;
                    };

                    /**
                     * Calculates the conjugate of a quat
                     * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {quat} a quat to calculate conjugate of
                     * @returns {quat} out
                     */
                    quat.conjugate = function (out, a) {
                        out[0] = -a[0];
                        out[1] = -a[1];
                        out[2] = -a[2];
                        out[3] = a[3];
                        return out;
                    };

                    /**
                     * Calculates the length of a quat
                     *
                     * @param {quat} a vector to calculate length of
                     * @returns {Number} length of a
                     * @function
                     */
                    quat.length = vec4.length;

                    /**
                     * Alias for {@link quat.length}
                     * @function
                     */
                    quat.len = quat.length;

                    /**
                     * Calculates the squared length of a quat
                     *
                     * @param {quat} a vector to calculate squared length of
                     * @returns {Number} squared length of a
                     * @function
                     */
                    quat.squaredLength = vec4.squaredLength;

                    /**
                     * Alias for {@link quat.squaredLength}
                     * @function
                     */
                    quat.sqrLen = quat.squaredLength;

                    /**
                     * Normalize a quat
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {quat} a quaternion to normalize
                     * @returns {quat} out
                     * @function
                     */
                    quat.normalize = vec4.normalize;

                    /**
                     * Creates a quaternion from the given 3x3 rotation matrix.
                     *
                     * NOTE: The resultant quaternion is not normalized, so you should be sure
                     * to renormalize the quaternion yourself where necessary.
                     *
                     * @param {quat} out the receiving quaternion
                     * @param {mat3} m rotation matrix
                     * @returns {quat} out
                     * @function
                     */
                    quat.fromMat3 = function (out, m) {
                        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
                        // article "Quaternion Calculus and Fast Animation".
                        var fTrace = m[0] + m[4] + m[8];
                        var fRoot;

                        if (fTrace > 0.0) {
                            // |w| > 1/2, may as well choose w > 1/2
                            fRoot = Math.sqrt(fTrace + 1.0);  // 2w
                            out[3] = 0.5 * fRoot;
                            fRoot = 0.5 / fRoot;  // 1/(4w)
                            out[0] = (m[5] - m[7]) * fRoot;
                            out[1] = (m[6] - m[2]) * fRoot;
                            out[2] = (m[1] - m[3]) * fRoot;
                        } else {
                            // |w| <= 1/2
                            var i = 0;
                            if (m[4] > m[0])
                                i = 1;
                            if (m[8] > m[i * 3 + i])
                                i = 2;
                            var j = (i + 1) % 3;
                            var k = (i + 2) % 3;

                            fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
                            out[i] = 0.5 * fRoot;
                            fRoot = 0.5 / fRoot;
                            out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
                            out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
                            out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
                        }

                        return out;
                    };

                    /**
                     * Returns a string representation of a quatenion
                     *
                     * @param {quat} vec vector to represent as a string
                     * @returns {String} string representation of the vector
                     */
                    quat.str = function (a) {
                        return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
                    };

                    if (typeof (exports) !== 'undefined') {
                        exports.quat = quat;
                    }
                    ;













                })(shim.exports);
            })(this);

        </script>
<script>
    function initShaders() {
        var fragmentShader;//test triangle
        {
            var fs_str = " \
		precision mediump float; \
		varying vec3 position_eye, normal_eye, out_Kd;	\
		varying mat4 out_Matrix_View; \
		void main(void) { \
			vec3 light_position_world = vec3(0.0, 0.0, 2.0); \
			vec3 Ls = vec3(1.0,1.0,1.0); \
			vec3 Ld = vec3(0.7,0.7,0.7); \
			vec3 La = vec3(0.2, 0.2, 0.2); \
			vec3 Ks = vec3(1.0, 1.0, 1.0); \
			vec3 Kd = out_Kd; \
			vec3 Ka = vec3(1.0, 1.0, 1.0); \
			float specular_exponent = 100.0;\
			vec3 Ia = La * Ka; \
			vec3 light_position_eye = vec3(out_Matrix_View * vec4(light_position_world, 1.0)); \
			vec3 distance_to_light_eye = light_position_eye - position_eye; \
			vec3 direction_to_light_eye = normalize(distance_to_light_eye);\
			float dot_prod = dot(direction_to_light_eye, normal_eye); \
			dot_prod = max(dot_prod, 0.0); \
			vec3 Id = Ld * Kd * dot_prod; \
			vec3 reflection_eye = reflect (-direction_to_light_eye, normal_eye); \
			vec3 surface_to_viewer_eye = normalize (-position_eye); \
			float dot_prod_specular = dot (reflection_eye, surface_to_viewer_eye); \
			dot_prod_specular = max (dot_prod_specular, 0.0); \
			float specular_factor = pow (dot_prod_specular, specular_exponent); \
			vec3 Is = Ls * Ks * specular_factor; \
			gl_FragColor = vec4(Is + Id + Ia, 1.0); \
		}	\
		";
            //
            //
            //
            //
            //
            //Id 
            fragmentShader = gl03.createShader(gl03.FRAGMENT_SHADER);
            gl03.shaderSource(fragmentShader, fs_str);
            gl03.compileShader(fragmentShader);

            if (!gl03.getShaderParameter(fragmentShader, gl03.COMPILE_STATUS)) {
                alert(gl03.getShaderInfoLog(fragmentShader));
                return null;
            }
        }//	
        var vertexShader;//test triangle
        {
            var vs_str = " \
		attribute vec3 aVertexPosition; \
		attribute vec3 aVertexNormals; \
		uniform mat4 Matrix_Projection; \
		uniform vec3 Kd; \
		uniform mat4 Matrix_View; \
		uniform mat4 Matrix_Model; \
		varying vec3 out_Kd; \
		varying vec3 position_eye, normal_eye; \
		varying mat4 out_Matrix_View; \
		void main(void) { \
			out_Matrix_View = Matrix_View; \
			position_eye = vec3(Matrix_View * Matrix_Model * vec4(aVertexPosition,1.0)); \
			normal_eye = vec3(Matrix_View * Matrix_Model * vec4(aVertexNormals,0.0)); \
			gl_PointSize = 2.0; \
			gl_Position = Matrix_Projection * Matrix_View * Matrix_Model * vec4(aVertexPosition.x,aVertexPosition.y,aVertexPosition.z, 1.0); \
			out_Kd = Kd; \
		}	\
		";
            vertexShader = gl03.createShader(gl03.VERTEX_SHADER);
            gl03.shaderSource(vertexShader, vs_str);
            gl03.compileShader(vertexShader);

            if (!gl03.getShaderParameter(vertexShader, gl03.COMPILE_STATUS)) {
                alert(gl03.getShaderInfoLog(vertexShader));
                return null;
            }
        }
        {//test triangle
            shaderProgramme = gl03.createProgram();
            gl03.attachShader(shaderProgramme, vertexShader);
            gl03.attachShader(shaderProgramme, fragmentShader);
            gl03.linkProgram(shaderProgramme);

            if (!gl03.getProgramParameter(shaderProgramme, gl03.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            shaderProgramme.vertexPositionAttribute = gl03.getAttribLocation(shaderProgramme, "aVertexPosition");
            gl03.enableVertexAttribArray(shaderProgramme.vertexPositionAttribute);

            shaderProgramme.vertexNormalsAttribute = gl03.getAttribLocation(shaderProgramme, "aVertexNormals");
            gl03.enableVertexAttribArray(shaderProgramme.vertexNormalsAttribute);

            shaderProgramme.Kd = gl03.getUniformLocation(shaderProgramme, "Kd");
            shaderProgramme.Matrix_View_Uniform = gl03.getUniformLocation(shaderProgramme, "Matrix_View");
            shaderProgramme.Matrix_Projection_Uniform = gl03.getUniformLocation(shaderProgramme, "Matrix_Projection");
            shaderProgramme.Matrix_Model_Uniform = gl03.getUniformLocation(shaderProgramme, "Matrix_Model");
        }

    }
</script>
<script>
    /*
     * Copyright 2010, Google Inc.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *     * Redistributions of source code must retain the above copyright
     * notice, this list of conditions and the following disclaimer.
     *     * Redistributions in binary form must reproduce the above
     * copyright notice, this list of conditions and the following disclaimer
     * in the documentation and/or other materials provided with the
     * distribution.
     *     * Neither the name of Google Inc. nor the names of its
     * contributors may be used to endorse or promote products derived from
     * this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */


    /**
     * @fileoverview This file contains functions every webgl program will need
     * a version of one way or another.
     *
     * Instead of setting up a context manually it is recommended to
     * use. This will check for success or failure. On failure it
     * will attempt to present an approriate message to the user.
     *
     *       gl = WebGLUtils.setupWebGL(canvas);
     *
     * For animated WebGL apps use of setTimeout or setInterval are
     * discouraged. It is recommended you structure your rendering
     * loop like this.
     *
     *       function render() {
     *         window.requestAnimFrame(render, canvas);
     *
     *         // do rendering
     *         ...
     *       }
     *       render();
     *
     * This will call your rendering function up to the refresh rate
     * of your display but will stop rendering if your app is not
     * visible.
     */

    WebGLUtils = function () {

        /**
         * Creates the HTLM for a failure message
         * @param {string} canvasContainerId id of container of th
         *        canvas.
         * @return {string} The html.
         */
        var makeFailHTML = function (msg) {
            return '' +
              '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' +
              '<td align="center">' +
              '<div style="display: table-cell; vertical-align: middle;">' +
              '<div style="">' + msg + '</div>' +
              '</div>' +
              '</td></tr></table>';
        };

        /**
         * Mesasge for getting a webgl browser
         * @type {string}
         */
        var GET_A_WEBGL_BROWSER = '' +
          'This page requires a browser that supports WebGL.<br/>' +
          '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';

        /**
         * Mesasge for need better hardware
         * @type {string}
         */
        var OTHER_PROBLEM = '' +
          "It doesn't appear your computer can support WebGL.<br/>" +
          '<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>';

        /**
         * Creates a webgl context. If creation fails it will
         * change the contents of the container of the <canvas>
         * tag to an error message with the correct links for WebGL.
         * @param {Element} canvas. The canvas element to create a
         *     context from.
         * @param {WebGLContextCreationAttirbutes} opt_attribs Any
         *     creation attributes you want to pass in.
         * @param {function:(msg)} opt_onError An function to call
         *     if there is an error during creation.
         * @return {WebGLRenderingContext} The created context.
         */
        var setupWebGL = function (canvas, opt_attribs, opt_onError) {
            function handleCreationError(msg) {
                var container = canvas.parentNode;
                if (container) {
                    var str = window.WebGLRenderingContext ?
                        OTHER_PROBLEM :
                         GET_A_WEBGL_BROWSER;
                    if (msg) {
                        str += "<br/><br/>Status: " + msg;
                    }
                    container.innerHTML = makeFailHTML(str);
                }
            };

            opt_onError = opt_onError || handleCreationError;

            if (canvas.addEventListener) {
                canvas.addEventListener("webglcontextcreationerror", function (event) {
                    opt_onError(event.statusMessage);
                }, false);
            }
            var context = create3DContext(canvas, opt_attribs);
            if (!context) {
                if (!window.WebGLRenderingContext) {
                    opt_onError("");
                }
            }
            return context;
        };

        /**
         * Creates a webgl context.
         * @param {!Canvas} canvas The canvas tag to get context
         *     from. If one is not passed in one will be created.
         * @return {!WebGLContext} The created context.
         */
        var create3DContext = function (canvas, opt_attribs) {
            var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
            var context = null;
            for (var ii = 0; ii < names.length; ++ii) {
                try {
                    context = canvas.getContext(names[ii], opt_attribs);
                } catch (e) { }
                if (context) {
                    break;
                }
            }
            return context;
        }

        return {
            create3DContext: create3DContext,
            setupWebGL: setupWebGL
        };
    }();

    /**
     * Provides requestAnimationFrame in a cross browser way.
     */
    window.requestAnimFrame = (function () {
        return window.requestAnimationFrame ||
               window.webkitRequestAnimationFrame ||
               window.mozRequestAnimationFrame ||
               window.oRequestAnimationFrame ||
               window.msRequestAnimationFrame ||
               function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
                   window.setTimeout(callback, 1000 / 60);
               };
    })();


</script>
<script>
    quat.product = function (a, b, c) {
        c || (c = a);
        var d = a[0], e = a[1], g = a[2]; a = a[3];
        var f = b[0], h = b[1], i = b[2]; b = b[3];
        c[0] = d * f - e * h - g * i - a * b;
        c[1] = d * h + e * f - g * b + a * i;
        c[2] = d * i + e * b + g * f - a * h;
        c[3] = d * b - e * i + g * h + a * f;
        return c
    };
</script>
<!--<script type="text/javascript" src="webgl-utils.js"></script>-->
<!--<script type="text/javascript" src="extra-utils.js"></script>-->
<!--<script type="text/javascript" src="shader.js"></script>-->
<!--<script type="text/javascript" src="UPS_Trolly.js"></script>-->
<script>
    var gl03;
    var web_programme;
    var test_triangle_programme;
    var generic_point_programme;
    var generic_triangles_programme;
    var shaderProgramme;
    var heightmap_programme;
    var texture_programme;
    var Matrix_Move = mat4.create();
    var web_lod_vp_Buffer;
    var lod_vp_Buffer;
    var lod_vc_Buffer;
    var RUNPOINTS = 0;
    var triangleVertexPosition;
    var triangleVertexColorBuffer;
    var squareVertexPositionBuffer;
    var squareVertexColorBuffer;
    var texture_test_vp_buffer;
    var texture_test_uv_buffer;
    var tri_vp = 0;
    var tri_vc = 0;
    var rTri = 0;
    var rSquare = 0;
    var float32arrayBuffer;
    var altitudes;
    var texture0;
    var texture1;
    var web_lod_texture;
    var web_lod_texture_height;
    var texture1_test_vp_buffer;
    var texture1_test_uv_buffer;
    var radial_sub = 1500.0;
    var TRIANGLE = 3;
    //light stuff
    var light_position_world = vec3.create();//fixed point light position
    var Ls = vec3.create(); // specular color
    var Ld = vec3.create(); //diffuse color
    var La = vec3.create(); //ambient color
    //surgace reflectance
    var Ks = vec3.create();//specular reflectance
    var Kd = vec3.create();//diffuse reflectance
    var Ka = vec3.create();//ambient reflectance
    var specular_exponent = 100.0; //specular power
    var test_triangle_normals_Buffer;//test triangles normals
    var far_clip = 100000.0;
    var sub_clip = 5000.0;
    var Matrix_Projection = mat4.create();
    var Martix_View = mat4.create();
    var m_eye = [0.0, 0.0, 0.0];
    var z_eye = [0.0, 0.0, 0.0];
    var m_xAxis = [1.0, 0.0, 0.0];
    var m_yAxis = [0.0, 1.0, 0.0];
    var m_zAxis = [0.0, 0.0, 1.0];
    var m_viewDir = [0.0, 0.0, -1.0];
    var m_orientation = [1.0, 0.0, 0.0, 0.0];
    var WORLD_XAXIS = [1.0, 0.0, 0.0];
    var WORLD_YAXIS = [0.0, 1.0, 0.0];
    var STD_DRAWINGS = {};
    var ASSETS = {};
    var triangleVertexPositionBuffer03;
    var triangleVertexColorBuffer03;
    var squareVertexPositionBuffer03;
    var squareVertexColorBuffer03;
    var rTri03 = 0;
    var rSquare03 = 0;
    var Colour = [
    [(53 + 1) / 256, (28 + 1) / 256, (21 + 1) / 256, 1.0],
    [(255 + 1) / 256, (181 + 1) / 256, (0 + 1) / 256, 1.0]
    ];
    var Maxtrix_Move = mat4.create();
    var mvMatrixStack03 = [];
    var pMatrix03 = mat4.create();


    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    function initGL03(canvas) {
        try {
            gl03 = canvas.getContext("experimental-webgl");
            gl03.viewportWidth = canvas.width;
            gl03.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl03) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    function mvPushMatrix03() {
        var copy = mat4.create();
        //mat4.set(mvMatrix03, copy);
        mat4.copy(copy, Matrix_Move);
        mvMatrixStack03.push(copy);
    }

    function mvPopMatrix03() {
        if (mvMatrixStack03.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix03 = mvMatrixStack03.pop();
    }

    var STD_DRAWINGS_Module_Pattern = function (VP, VC) {
        var _id = +(new Date());
        var privateMethod = function () { alert(_id); };

        var VP_Buffer = gl03.createBuffer();//Vertex Positions
        gl03.bindBuffer(gl03.ARRAY_BUFFER, VP_Buffer);//Create Buffer for Vertex Positions
        gl03.bufferData(gl03.ARRAY_BUFFER, new Float32Array(VP), gl03.STATIC_DRAW);
        VP_Buffer.itemSize = TRIANGLE;
        VP_Buffer.numItems = VP.length / VP_Buffer.itemSize;

        var VC_Buffer = gl03.createBuffer();//Normals
        gl03.bindBuffer(gl03.ARRAY_BUFFER, VC_Buffer);//Create Buffer for Vertex Normals
        gl03.bufferData(gl03.ARRAY_BUFFER, new Float32Array(VC), gl03.STATIC_DRAW);
        VC_Buffer.itemSize = VP_Buffer.itemSize;
        VC_Buffer.numItems = VP_Buffer.numItems;

        // All methods and members defined here are public
        return {
            VP_Buffer: VP_Buffer,
            VC_Buffer: VC_Buffer,
            getName: function () {
                return this.name + " " + _id;
            },
            setName: function (name) {
                this.name = name;
            },
            Verticies: function (name) {
                this.name = name;
            },
            setVerticies: function (name) {
                this.name = name;
            },
            Normals: function (name) {
                this.name = name;
            },
            setNormals: function (name) {
                this.name = name;
            }
        };
    };

    //ASSETS[740144] = ASSETS_Module_Pattern("MF4-2TAI-02"     ,"MF4-2"    ,"TAI-02"   ,"740052","OPERATING",0,0);
    var ASSETS_Module_Pattern = function (DESC, name, component, PARENT, status, location, height) {
        var _id = +(new Date());
        var privateMethod = function () { alert(_id); };
        //var Kd = vec3.create(255 / 255, 181 / 255, 0 / 255);
        var Kd = vec3.create();
        vec3.set(Kd, 255 / 255, 181 / 255, 0 / 255);//COLOR derive from status, DECOM=RED, DRAFT=AQUA, ACTUAL=DARK GREY
        var POS = vec3.create();
        vec3.set(POS, Math.floor(location), height, -position_z(location));
        // All methods and members defined here are public
        return {
            name: name,
            Kd: Kd,
            component: component,
            _status: status,
            _location: location,
            _height: height,
            getName: function () {
                return this.name + " " + _id;
            },
            setName: function (name) {
                this.name = name;
            },
            test: 34,
            TYPE: function () {
                return this._component;
            },
            POS: POS,
            X: Math.floor(location),
            Y: height,
            Z: position_z(location),
            getKd: function () {
                return this._Kd;
            }
        };
    };





    //Reverse location decimal fields up to 6 digits to use as Z value
    function position_z(location) {
        return Number(Math.round(location % 1 * 1000000 + Number.EPSILON).toString().split("").reverse().join(""));
    }


    function initBuffers03() {
        {//Lighting Parameters
            //light stuff
            vec3.set(light_position_world, 10.0, 10.0, 10.0);//fixed point light position
            vec3.set(Ls, 1.0, 1.0, 1.0); // specular color
            vec3.set(Ld, 0.7, 0.7, 0.7); //diffuse color
            vec3.set(La, 0.2, 0.2, 0.2);//ambient color
            //surgace reflectance
            vec3.set(Ks, 1.0, 1.0, 1.0);//specular reflectance // color of reflective surfaces
            vec3.set(Kd, 1.0, 0.5, 0.0);//diffuse reflectance // color of object
            vec3.set(Ka, 1.0, 1.0, 1.0);//ambient reflectance //color of object in shadow
            var specular_exponent = 100.0; //specular power
            //gl03.uniformMatrixvec3(shaderProgramme.Kd, false, Kd);
        }
        //Here is where we could pull AJAX/PHP from STD_DRAWINGS archive if we evolve our standard drawings, till then we will manually define component verticies
        STD_DRAWINGS["DRI-34"] = STD_DRAWINGS_Module_Pattern(
            //First draft @ 36" belt
            //Vertex Positions
            [-21, -10.74999905, 18.49999809, 21, -10.75, 18.50000381, -21, 10.75000095, 18.49999809, 21, -10.74999905, 18.5, 21, 10.75000095, 18.5, -21, 10.74999905, 18.5, -21, 10.75, 18.5, 21, 10.75, 18.5, -21, 10.75, -18.5, 21, 10.75, 18.5, 21, 10.75, -18.5, -21, 10.75, -18.5, -21, 10.74999905, -18.49999809, 21, 10.75, -18.50000381, -21, -10.75000095, -18.49999809, 21, 10.74999905, -18.5, 21, -10.75000095, -18.5, -21, -10.74999905, -18.5, -21, -10.75, -18.5, 21, -10.75, -18.5, -21, -10.75, 18.5, 21, -10.75, -18.5, 21, -10.75, 18.5, -21, -10.75, 18.5, 21.00000572, -10.75000095, 18.5, 20.99999809, -10.75, -18.5, 21.00000572, 10.74999905, 18.5, 21.00000572, -10.74999905, -18.5, 21.00000572, 10.75000095, -18.5, 20.99999809, 10.75, 18.5, -21.00000572, -10.75000095, -18.5, -20.99999809, -10.75, 18.5, -21.00000572, 10.74999905, -18.5, -21.00000572, -10.74999905, 18.5, -21.00000572, 10.75000095, 18.5, -20.99999809, 10.75, -18.5]

            ,
            //Vertex Normals
            [-0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 1.000000, -0.000000, -0.000000, 1.000000, -0.000000, -0.000000, 1.000000, -0.000000, -0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, 0.000000, -0.000000, -1.000000, 0.000000, -0.000000, -1.000000, 0.000000, -0.000000]


            );
        STD_DRAWINGS["TAI-10"] = STD_DRAWINGS_Module_Pattern(
            //Vertex Positions
            [-7.999999046, -5.499999523, 0.1874995977, 7.999999046, -5.5, 0.1874996424, -7.999999046, 5.499999523, 0.1874996275, 7.999999046, -5.500000477, 0.1874995977, 8.000000954, 5.499999523, 0.1874995083, -8.000000954, 5.5, 0.187499553, -7.999999046, 5.500000477, 0.1874994934, 7.999999046, 5.500000477, 0.1874994934, -8, 5.5, -0.1875, 8, 5.5, 0.1875, 8, 5.5, -0.1875, -8, 5.5, -0.1875, -8, 5.5, -0.187499404, 8, 5.500000477, -0.1874995679, -8, -5.5, -0.1874994338, 8, 5.5, -0.1874998957, 8, -5.5, -0.1874999106, -8, -5.500000477, -0.1874999702, -8, -5.5, -0.1875, 8, -5.5, -0.1875, -8, -5.5, 0.1875, 8, -5.5, -0.1875, 8, -5.5, 0.1875, -8, -5.5, 0.1875, 8, -5.5, 0.1875, 8, -5.5, -0.1875, 8, 5.5, 0.1875, 8, -5.5, -0.1875, 8, 5.5, -0.1875, 8, 5.5, 0.1875, -8, -5.5, -0.1875, -8, -5.5, 0.1875, -8, 5.5, -0.1875, -8, -5.5, 0.1875, -8, 5.5, 0.1875, -8, 5.5, -0.1875, 1.999999881, -3.999999762, 2.187499762, 5.624999523, -3.999999762, 2.187499762, 1.999999881, -3.624999762, 2.187499762, 5.625, -4, 2.1875, 5.625, -3.625, 2.1875, 2, -3.625, 2.1875, -0.375, -1.250000596, 2.1875, 2, -3.625, 2.1875, -0.375, -1.250000596, 0.1875, 5.625, -3.625, 2.1875, 5.625, -3.625, 0.1874999851, 2, -3.625, 2.1875, 5.625, -3.624999762, 0.1874999851, 2, -3.624999762, 0.1875000149, 2, -3.624999762, 2.1875, 2, -3.625, 2.1875, 2, -3.625, 0.1874999255, -0.3749999702, -1.250000715, 0.1874999553, -0.3750000596, -1.250000715, 0.1875, 2, -3.625, 0.1875, -0.3750000596, -1.625000715, 0.1875, 2, -3.625, 0.1875000149, 2, -4, 0.1875000149, -0.3749999404, -1.625000715, 0.1875000149, -0.375, -1.625000715, 0.1875, 2, -4, 0.1875001043, -0.375, -1.625000477, 2.187500238, 5.625, -4, 0.1875000149, 5.625, -4, 2.1875, 2, -4, 0.1874999851, 5.625, -4, 2.1875, 2, -4, 2.1875, 2, -4, 0.1875, 1.999999881, -4, 0.1874999702, 1.999999881, -4, 2.1875, -0.375, -1.625000596, 2.1875, 5.625, -3.999999762, 2.1875, 5.625, -4, 0.1875000596, 5.625, -3.624999762, 2.1875, 5.625000477, -4, 0.1874999851, 5.625000477, -3.625, 0.1874999851, 5.624999523, -3.624999523, 2.187499762, -0.3750000298, -1.625000834, 0.1875, -0.3750000298, -1.625000596, 2.1875, -0.3750000298, -1.250000834, 0.1875, -0.375, -1.625000477, 2.1875, -0.375, -1.250000715, 2.1875, -0.3750000298, -1.250000715, 0.1875000596, 2, -4, 2.1875, 2, -3.625, 2.1875, -0.3749999106, -1.625000477, 2.1875, -0.3750000298, -1.625000477, 2.1875, 2, -3.625, 2.1875, -0.3750000298, -1.250000715, 2.1875, 2, -3.625, 0.1875, 5.625, -3.625, 0.1875, 2, -4, 0.1875, 5.625, -3.625, 0.1875, 5.625, -4, 0.1875, 2, -4, 0.1875, -0.375, -1.625, 2.1875, -0.375, -1.624999523, 2.1875, -0.375, 2, 2.1875, 4.9670561e-009, -2, 2.1875, 4.9670561e-009, 2, 2.1875, -0.375, -1.624999523, 2.1875, -0.375, -1.624999523, 2.1875, -1.027660179e-008, 2, 2.1875, -0.375, 2, 2.1875, -0.375, 2, 2.1875, -5.541478387e-009, 2, 2.1875, -0.375, 2, 0.1875, -5.394538982e-011, 2, 2.1875, 4.548973698e-011, 2, 0.1875, -0.375, 2, 0.1875, -0.375, -1.625, 0.1875, -0.375, 2, 0.1875, -0.375, -1.625000477, 0.1875, 0, -2, 0.1875, -0.375, -1.625000477, 0.1875, 0, 2, 0.1875, -0.375, 2, 0.1875, 8.221330283e-009, 2, 0.1875, -0.375, -1.625000477, 0.1875, -0.3749999702, -1.625000477, 0.1875000149, -3.883834587e-009, -2, 0.1874999404, -0.3749999702, -1.624999523, 2.1875, 7.397981117e-010, -1.999999881, 0.1874998361, 7.397979451e-010, -1.999999881, 2.1875, -0.3749999702, -1.624999404, 2.1875, 0, -2, 2.1875, 0, -2, 0.1875, 0, 2, 2.1875, 0, -2, 0.1875, 0, 2, 0.1875, 0, 2, 2.1875, -0.3749999702, -1.625000119, 0.1875001192, -0.3749999702, -1.625000596, 0.1875001192, -0.3750000298, -1.625000119, 2.1875, -0.375, -1.625000477, 0.1875, -0.375, -1.624999523, 2.1875, -0.375, -1.625, 2.1875, -0.375, -1.625, 0.1875, -0.375, -1.625, 2.1875, -0.375, 2, 0.1875, -0.375, -1.625, 2.1875, -0.375, 2, 2.1875, -0.375, 2, 0.1875, -0.375, 2.000000238, 2.187500238, -1.210465772e-008, 2.000000238, 2.187500238, -0.3750000298, 4, 0.1875003129, 5.774807299e-009, 1.999999762, 2.1875, 1.73363599e-008, 3.999999762, 0.1874999553, -0.3749999702, 3.999999762, 0.1874999553, -0.375, 4, 0.1875, -0.375, 4, 0.1875, 0, 4, 0.1875, -0.375, 4, 0.1875, 0, 4, 0.1875, 0, 4, 0.1875, -0.375, 4, 0.1875, 1.724373533e-009, 4, 0.1875, -0.375, 2, 0.1875, 1.185823439e-009, 4, 0.1875, -9.99951677e-010, 2, 0.1875, -0.375, 2, 0.1875, -0.375, 2, 0.1875, 1.221659329e-009, 2, 0.1875, -0.375, 2, 2.1875, 6.073154868e-009, 2, 0.1875, 8.612102143e-009, 2, 2.1875, -0.375, 2, 2.1875, 0, 2, 2.1875, 0, 2, 0.1875, 0, 4, 0.1875, -0.375, 4, 0.1875, -0.375, 2, 0.1875, -0.375, 4, 0.1875, -0.3750000298, 2, 0.1875, -0.3750000298, 2, 2.1875, -0.3750000298, 4, 0.1875, 0, 2, 2.1875, 0, 4, 0.1875, 0, 4, 0.1875, 2, -4, 2.5625, 2, -4, 2.5625, -0.375, -1.625, 2.5625, 3.625, 2, 2.5625, 5.625, 0, 2.5625, 3.625, 1.999999881, 2.5625, 3.625, 1.999999881, 2.187500238, 3.625, 1.999999881, 2.562500238, 5.624999523, -1.005636534e-007, 2.187500238, 3.625, 1.999999762, 2.5625, 5.625, 4.097657325e-008, 2.5625, 5.625, 4.097657325e-008, 2.1875, -0.375, -1.625, 2.1875, -0.375, 2, 2.1875, -0.375, -1.625, 2.1875, 5.625, -3.999999762, 2.1875, -0.375, -1.624999881, 2.1875, 5.625, 1.514035972e-007, 2.1875, 5.625, 7.963445015e-009, 2.1875, -0.3749999404, -1.625, 2.1875, 3.625, 1.999999881, 2.1875, -0.375, 2, 2.1875, 0, 2, 2.1875, -0.375, -1.625, 2.1875, 1.998401444e-015, 2, 2.1875, 3.625, 1.999999881, 2.1875, -0.375, -1.625, 2.1875, 2, -4, 2.5625, 2, -4, 2.1875, 2, -4, 2.5625, -0.3750000298, -1.625, 2.1875, 5.625, -3.999999523, 2.1875, 2, -3.999999762, 2.1875, 5.625, -4, 2.187500238, 5.625, -4, 2.562500238, 2.000000238, -4, 2.187500238, 5.625, -4, 2.562499762, 1.999999762, -4, 2.562499762, 1.999999762, -4, 2.187499762, 5.625, -4, 2.5625, 5.625, -4, 2.1875, 5.625, 4.106316176e-009, 2.5625, 5.625, -4, 2.1875, 5.625, -1.172317243e-010, 2.1875, 5.625, 3.307411289e-010, 2.5625, -0.375, 2, 2.1875, -0.375, -1.625, 2.1875, -0.375, 2, 2.1875, -0.3749999702, 2, 2.1875, -0.3749999702, -1.625, 2.1875, -0.3749999702, 1.625, 2.5625, -0.375, 1.625, 2.5625, -0.375, -1.625, 2.1875, -0.375, 1, 2.5625, -0.375, 1, 2.5625, -0.375, -1.625, 2.1875, -0.375, -0.5426555276, 2.5625, -0.375, -0.5426555276, 2.5625, -0.375, -1.625, 2.1875, -0.375, -1.625, 2.5625, 1.999999762, -3.999999762, 2.187499523, 1.999999762, -3.999999762, 2.562499523, -0.3750000596, -1.625, 2.1875, 1.999999881, -3.999999523, 2.562499523, -0.3749999404, -1.625, 2.5625, -0.3749999404, -1.625, 2.1875, -0.3749999702, 1.624999881, 2.562499762, -0.004554957617, 1.999999881, 2.562499762, -0.3749999702, 1.999999881, 2.187499762, -0.375, 1, 2.5625, 1.6875, 2, 2.5625, -0.375, 1.625, 2.5625, 1.687500119, 2.000000238, 2.562500238, 6.030162325e-008, 2.000000238, 2.562500238, -0.3749999404, 1.625000238, 2.562500238, -1.47209418e-008, 2, 2.5625, -0.004555001855, 2, 2.5625, -0.3750000298, 1.625, 2.5625, 3.625, 1.999999881, 2.5625, 1.6875, 2, 2.5625, 3.625, 2, 2.5625, 3.625, 2, 2.562500238, 1.6875, 2, 2.5625, -0.375, -0.5426555276, 2.562499762, -0.375, -0.542655468, 2.5625, 1.6875, 2, 2.5625, -0.375, 1, 2.5625, -9.139267121e-011, 2, 2.5625, 1.6875, 2, 2.5625, 2.380184938e-010, 2, 2.1875, -6.470934011e-008, 2, 2.1875, 1.687499881, 2, 2.5625, 3.625, 1.999999881, 2.1875, 1.687500119, 2.000000238, 2.5625, 3.625, 2, 2.5625, 3.625, 2, 2.1875, -0.375, 2, 2.1875, -0.004555002321, 2, 2.5625, -0.375, 2, 2.1875, -1.675966223e-012, 2, 2.5625, 1.696323203e-012, 2, 2.1875, -0.004554986954, 2, 2.5625, -0.004554986954, 2, 2.5625, 7.121561674e-011, 2, 2.1875, -0.375, 2, 2.1875, 5.625, -4, 2.5625, 5.625, 2.845960623e-008, 2.5625, 2, -4, 2.5625, 2, -4, 2.5625, 5.625, -1.585207912e-007, 2.5625, -0.375, -1.625000119, 2.5625, -0.3750000894, -1.625, 2.5625, 5.625, 3.624088762e-008, 2.5625, -0.3750000894, -0.5426555872, 2.5625, 5.625, 7.843434346e-009, 2.562500238, 3.625, 2, 2.562500238, -0.3749998212, -0.5426555276, 2.562500238, -0.375, -1.625, 2.1875, 2, -4, 2.1875, -0.375, -1.625, 2.1875],
            //Vertex Normals
            [-0.000000, -0.000000, 1.000000, -0.000000, -0.000000, 1.000000, -0.000000, -0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, -0.000002, 0.000000, 1.000000, -0.000002, 0.000000, 1.000000, -0.000002, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.707107, 0.707107, -0.000000, 0.707107, 0.707107, -0.000000, 0.707107, 0.707107, -0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.707107, 0.707107, -0.000000, 0.707107, 0.707107, -0.000000, 0.707107, 0.707107, -0.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, -0.707107, -0.707107, 0.000000, -0.707107, -0.707107, 0.000000, -0.707107, -0.707107, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, -0.707107, -0.707107, -0.000000, -0.707107, -0.707107, -0.000000, -0.707107, -0.707107, -0.000000, 1.000000, 0.000001, 0.000000, 1.000000, 0.000001, 0.000000, 1.000000, 0.000001, 0.000000, 1.000000, -0.000001, 0.000000, 1.000000, -0.000001, 0.000000, 1.000000, -0.000001, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, -0.707106, -0.707107, 0.000000, -0.707106, -0.707107, 0.000000, -0.707106, -0.707107, 0.000000, -0.707107, -0.707106, -0.000000, -0.707107, -0.707106, -0.000000, -0.707107, -0.707106, -0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, -0.999512, -0.031235, -0.000000, -0.999512, -0.031235, -0.000000, -0.999512, -0.031235, -0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, 0.000000, 0.707107, 0.707107, 0.000000, 0.707107, 0.707107, 0.000000, 0.707107, 0.707107, -0.000000, 0.707107, 0.707107, -0.000000, 0.707107, 0.707107, -0.000000, 0.707107, 0.707107, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.707107, 0.707107, 0.000000, 0.707107, 0.707107, 0.000000, 0.707107, 0.707107, 0.000000, 0.707106, 0.707107, 0.000000, 0.707106, 0.707107, 0.000000, 0.707106, 0.707107, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -0.707107, -0.707107, 0.000000, -0.707107, -0.707107, 0.000000, -0.707107, -0.707107, 0.000000, -0.707107, -0.707107, -0.000000, -0.707107, -0.707107, -0.000000, -0.707107, -0.707107, -0.000000, -0.582054, 0.574984, 0.574984, -0.582054, 0.574984, 0.574984, -0.582054, 0.574984, 0.574984, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, -0.099305, 0.995057, 0.000000, -0.099305, 0.995057, 0.000000, -0.099305, 0.995057, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, -0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000]
            );
        STD_DRAWINGS["TRA-M"] = STD_DRAWINGS_Module_Pattern(
            [9.838172707, 22.60625392, 34.31904781, -4.199404922, 21.14027435, -5.283554191, 9.895021233, 22.72810584, 34.29342449, 9.895019325, 22.72810489, 34.29342449, -4.199406353, 21.14027435, -5.283555145, -4.142558304, 21.26212627, -5.309178467, 9.748309883, 22.50955707, 34.35524166, -4.289267269, 21.04357177, -5.247361297, 9.838170799, 22.60625869, 34.31904781, 9.838172707, 22.60625869, 34.31905544, -4.289266792, 21.04357177, -5.247360344, -4.199405876, 21.14027435, -5.283553238, 9.634227547, 22.44746429, 34.39845455, -4.40334436, 20.98148662, -5.204141731, 9.748304161, 22.50955135, 34.35523403, 9.748309883, 22.50955421, 34.35524166, -4.403344837, 20.98148566, -5.204142685, -4.289268699, 21.04357177, -5.247363205, 9.507108483, 22.42607433, 34.44447506, -4.530468193, 20.96009189, -5.158123131, 9.634233269, 22.4474681, 34.39845837, 9.634231362, 22.44746619, 34.39846218, -4.530469147, 20.96009189, -5.158124084, -4.403343407, 20.98148566, -5.204141731, 9.507106575, 22.42607337, 34.44447506, 9.379375252, 22.44746715, 34.48878277, -4.5304701, 20.96009189, -5.158124084, 9.379375252, 22.44746429, 34.48878277, -4.65820047, 20.98148471, -5.113816375, -4.530469623, 20.96009094, -5.158125992, 9.379379067, 22.44746906, 34.48878658, 9.263545784, 22.50955611, 34.52705181, -4.658199516, 20.98148662, -5.113813514, 9.263547692, 22.50955421, 34.52705181, -4.774033275, 21.04357082, -5.075552101, -4.658199993, 20.98148471, -5.113815422, 9.263540062, 22.50955325, 34.527048, 9.170944008, 22.60625583, 34.5555209, -4.774034229, 21.04357177, -5.075551147, 9.170945915, 22.60625869, 34.55552853, -4.866629806, 21.14027435, -5.047077293, -4.774033275, 21.04357177, -5.075551147, 9.170945915, 22.60625583, 34.5555209, 9.110648903, 22.72810775, 34.57141674, -4.866629806, 21.14027435, -5.047075386, 9.11065081, 22.72810584, 34.57141674, -4.926926342, 21.26212531, -5.031183357, -4.866630283, 21.14027339, -5.047078247, 9.110648903, 22.7281068, 34.57142056, 9.088556084, 22.86318046, 34.57318295, -4.926926342, 21.26212722, -5.03118145, 9.088557991, 22.86318332, 34.57319439, -4.949020115, 21.39719993, -5.029420967, -4.926926342, 21.26212627, -5.031182403, 9.088557991, 22.86318141, 34.57318295, 9.106830391, 22.99825507, 34.56063641, -4.949020115, 21.39719993, -5.029421921, 9.106830391, 22.99825698, 34.56063641, -4.930747238, 21.53227454, -5.041964645, -4.949019161, 21.39720088, -5.029420013, 9.106830391, 22.99825603, 34.56063641, 9.163678917, 23.12010795, 34.53501308, -4.930748192, 21.53227264, -5.041966552, 9.163678917, 23.12010795, 34.53501308, -4.873899666, 21.65412551, -5.067589874, -4.930748192, 21.53227359, -5.041966552, 9.163678917, 23.12010795, 34.53502071, 9.253537926, 23.21681052, 34.49882687, -4.873899666, 21.65412551, -5.06758892, 9.253534111, 23.21680957, 34.49881161, -4.78403875, 21.75082618, -5.103783722, -4.873899189, 21.6541236, -5.067589874, 9.253539833, 23.21681243, 34.49882305, 9.367616448, 23.27889854, 34.45560253, -4.784038273, 21.75082809, -5.103783722, 9.36761454, 23.27889472, 34.45559872, -4.669962612, 21.81291515, -5.147003288, -4.78403875, 21.75082809, -5.103782768, 9.367612633, 23.27889377, 34.4555949, 9.494739327, 23.30028754, 34.40957821, -4.669962612, 21.81291419, -5.147005195, 9.494741234, 23.30029136, 34.40958584, -4.542837349, 21.83430797, -5.193019981, -4.669963089, 21.81291515, -5.147003288, 9.62247065, 23.27889663, 34.36527432, -4.415105072, 21.81291515, -5.237329597, 9.494741234, 23.30029041, 34.40958202, 9.494741234, 23.30028945, 34.40958202, -4.415105549, 21.81291515, -5.237329597, -4.542836395, 21.83430797, -5.193019981, 9.738302025, 23.21680957, 34.32700909, -4.29927322, 21.75082713, -5.275593872, 9.622468743, 23.27889568, 34.36527432, 9.62247065, 23.27889854, 34.36527813, -4.29927322, 21.75082904, -5.275594825, -4.415106502, 21.8129161, -5.237330551, 9.830901894, 23.12010795, 34.29853619, -4.206675735, 21.65412551, -5.304066772, 9.738303932, 23.21681052, 34.32700909, 9.738302025, 23.21680957, 34.32700909, -4.206676212, 21.65412551, -5.304065819, -4.299272743, 21.75082809, -5.275592918, 9.891196999, 22.99825507, 34.28264034, -4.146379677, 21.53227359, -5.319961662, 9.830901894, 23.12010795, 34.29853619, 9.830901894, 23.1201089, 34.29854382, -4.146378723, 21.53227359, -5.319960708, -4.206675735, 21.65412551, -5.304065819, 9.913287911, 22.86318046, 34.28087414, -4.124287811, 21.39719898, -5.321724052, 9.891193184, 22.99825412, 34.28263653, 9.891198906, 22.99825889, 34.28264416, -4.124286857, 21.39719993, -5.321723098, -4.146379677, 21.53227359, -5.319961662, 9.895019325, 22.7281087, 34.29342449, -4.142558304, 21.26212531, -5.309177513, 9.913291725, 22.86318332, 34.28087795, 9.913293633, 22.86318332, 34.28087795, -4.142558304, 21.26212627, -5.309178467, -4.124286857, 21.39719993, -5.321723098, -4.145683494, 21.27375346, -5.376854057, -4.207774845, 21.16167957, -5.425021286, -4.453742233, 24.03922969, -11.50705254, -4.207774368, 21.16167957, -5.425021286, -4.515833584, 23.92715579, -11.55522024, -4.453741756, 24.03922969, -11.50705206, -4.207774368, 21.16168052, -5.425021286, -4.30448505, 21.0719493, -5.461511726, -4.515833107, 23.92715675, -11.55522024, -4.304486004, 21.07194835, -5.461511726, -4.612545696, 23.83742458, -11.59171116, -4.515834537, 23.92715579, -11.55522072, -4.304486004, 21.0719493, -5.461510772, -4.426348892, 21.01334506, -5.48275196, -4.612545696, 23.83742553, -11.5917102, -4.426347938, 21.01334506, -5.482752914, -4.734407154, 23.77882129, -11.61295139, -4.612544266, 23.83742553, -11.59171068, -4.426347462, 21.01334316, -5.482753868, -4.561433521, 20.99160129, -5.48666584, -4.734407154, 23.77881938, -11.61295235, -4.561433998, 20.99160224, -5.486663933, -4.869493213, 23.75707942, -11.61686241, -4.734407631, 23.77882034, -11.61295044, -4.561433998, 20.99160129, -5.48666584, -4.696519581, 21.00885135, -5.472866173, -4.869493213, 23.75707942, -11.61686432, -4.696519104, 21.00885326, -5.472864265, -5.004578796, 23.77433044, -11.60306322, -4.869492737, 23.75708038, -11.61686289, -4.696519104, 21.00885326, -5.472865219, -4.818381992, 21.06340629, -5.442704315, -5.004577843, 23.77433139, -11.60306274, -4.8183839, 21.06340247, -5.442706222, -5.126443592, 23.82887775, -11.57290518, -5.00458118, 23.77432567, -11.6030656, -4.8183839, 21.06340438, -5.442705269, -4.915094581, 21.14991981, -5.399136657, -5.126442638, 23.82888061, -11.57290375, -4.91509172, 21.14992172, -5.39913475, -5.223151413, 23.91539794, -11.52933371, -5.126440254, 23.82888252, -11.57290279, -4.915092674, 21.14992076, -5.399135704, -4.977184978, 21.25993091, -5.34642231, -5.223152366, 23.91539699, -11.52933418, -4.977185932, 21.25993091, -5.346423263, -5.285245148, 24.02540714, -11.47662127, -5.22315332, 23.91539699, -11.52933418, -4.998580662, 21.38266689, -5.289726372, -5.306639877, 24.14814311, -11.41992437, -4.977184978, 21.25993186, -5.34642231, -4.977184978, 21.25993091, -5.346423263, -5.306639877, 24.14814121, -11.41992533, -5.285244194, 24.02540618, -11.47662174, -4.977185455, 21.50611144, -5.234596367, -5.285245148, 24.27158672, -11.36479437, -4.998581138, 21.38266498, -5.289727325, -4.998581138, 21.38266593, -5.289726372, -5.285245148, 24.27158767, -11.36479341, -5.306640354, 24.14814121, -11.41992437, -4.915093628, 21.61818725, -5.186427231, -5.223153797, 24.38366252, -11.31662619, -4.977185932, 21.50611335, -5.234595413, -4.977185932, 21.50611144, -5.234595413, -5.22315332, 24.38366157, -11.31662571, -5.285245148, 24.27158767, -11.36479341, -4.818382469, 21.70791751, -5.14993679, -5.126441685, 24.47339374, -11.28013479, -4.915093151, 21.61818629, -5.186427231, -4.915092674, 21.61818629, -5.186428184, -5.126441208, 24.47339374, -11.28013575, -5.223152366, 24.38366252, -11.31662619, -4.696520534, 21.76652175, -5.128696556, -5.004580227, 24.53199798, -11.25889456, -4.818383423, 21.70791751, -5.14993679, -4.818381992, 21.70791942, -5.14993679, -5.004579273, 24.53199989, -11.25889503, -5.126441685, 24.47339565, -11.28013575, -4.561433998, 21.78826267, -5.12478363, -4.869493213, 24.55373985, -11.25498306, -4.696519581, 21.76652175, -5.128695602, -4.696519581, 21.76652175, -5.128695602, -4.869493213, 24.5537408, -11.25498211, -5.004579273, 24.53199893, -11.25889408, -4.426347938, 21.77101356, -5.138584251, -4.734408108, 24.53648978, -11.26878273, -4.561433998, 21.78826267, -5.124784584, -4.561433521, 21.78826362, -5.124784584, -4.734407154, 24.53649074, -11.26878225, -4.869492737, 24.5537408, -11.25498259, -4.30448505, 21.71646243, -5.168743248, -4.612545219, 24.48193675, -11.29894316, -4.426347462, 21.77101547, -5.138583297, -4.426347462, 21.77101451, -5.138584251, -4.612542835, 24.48193961, -11.29894173, -4.734405723, 24.53649265, -11.2687813, -4.207772461, 21.62994701, -5.212312813, -4.515833107, 24.39542228, -11.34251129, -4.30448362, 21.71646243, -5.168743248, -4.304484573, 21.71646053, -5.168743248, -4.515833584, 24.39542133, -11.34251129, -4.612544266, 24.48193675, -11.2989422, -4.145682541, 21.51993495, -5.265026207, -4.453742233, 24.28541213, -11.39522516, -4.207774845, 21.6299451, -5.212313766, -4.207774368, 21.62994415, -5.212312813, -4.453741756, 24.28541118, -11.39522469, -4.51583406, 24.39542037, -11.34251177, -4.145682541, 21.51993591, -5.265025253, -4.124286857, 21.39720088, -5.321722145, -4.453741279, 24.28541309, -11.39522421, -4.124286857, 21.39720088, -5.321723098, -4.432346073, 24.16267806, -11.45192158, -4.453741756, 24.28541309, -11.39522516, -4.124286857, 21.39719993, -5.321723098, -4.145682541, 21.27375346, -5.376854057, -4.432345596, 24.16267806, -11.45192158, -4.145681587, 21.27375442, -5.376854057, -4.453740803, 24.03922969, -11.50705206, -4.432345119, 24.16267711, -11.45192158, -4.43234655, 14.15146905, -10.19519054, 9.067651543, 14.15146857, -10.19519054, -4.43234655, 14.956168, -12.02616012, 9.067651543, 14.15146834, -10.1951915, 9.067651543, 14.95616633, -12.02615773, -4.432347027, 14.95616752, -12.02616059, -4.432345119, 14.95616895, -12.02615511, 9.067651543, 14.95616633, -12.02615702, -4.432345119, 16.15705186, -11.49804794, 9.067651543, 14.95616657, -12.02615773, 9.067651543, 16.15705234, -11.52321922, -4.432345119, 16.15705186, -11.4980489, -4.124288765, 21.39719611, -5.321716423, -4.432346073, 13.53554612, -5.686994667, -3.15033361, 20.2047208, -2.67837059, -4.432345596, 13.5355466, -5.68699562, -4.124287811, 21.39719802, -5.321716423, -4.432346073, 16.15705234, -11.49804937, -4.124288765, 21.39719707, -5.321716423, -4.43234655, 24.16267711, -11.45192158, -4.432346073, 16.15705186, -11.4980489, -4.432345596, 16.15705234, -11.4980489, -4.432345596, 24.16267616, -11.45192158, -4.432345596, 16.67107326, -12.63747131, -4.432346073, 24.16267711, -11.4519211, -4.432346073, 17.49350482, -14.4605441, -4.432346073, 16.67107326, -12.63747107, 9.067649635, 11.2723289, -0.5373860547, -4.43234655, 13.53554636, -5.68699562, 9.067651543, 16.15705186, -11.5232197, -4.432346073, 16.15705186, -11.49804842, 9.067651543, 16.15705138, -11.52321922, -4.432346073, 13.53554612, -5.686994667, 9.067649635, 16.15705281, -11.5232197, 9.067649635, 14.97028118, -12.02162635, 9.067649635, 11.27232889, -0.5373860547, 9.067651543, 14.97028095, -12.02162539, 9.067651543, 10.12858826, -1.041729088, 9.067651543, 11.27232874, -0.5373851011, 9.06765345, 15.00389129, -12.01074564, 7.067655358, 15.00388986, -12.01074254, 9.06765345, 10.13006669, -1.045073623, 7.067655358, 15.00388986, -12.01074182, 7.067655358, 10.13006681, -1.04507267, 9.06765345, 10.13006681, -1.04507267, -4.330596653, 21.39719993, -6.023588295, -4.432345596, 13.53554612, -5.686994667, -4.124285904, 21.39719993, -5.321723098, 9.913291725, 22.86318427, 34.28088558, -4.124285904, 21.39719993, -5.321723098, 9.869655403, 22.26509124, 34.27736462, 9.869653496, 22.26508933, 34.27735699, -4.124286857, 21.39719993, -5.321725006, 9.06765345, 11.2723282, 34.21261395, -4.124287811, 21.39719898, -5.32172596, -4.43234655, 13.53554636, -5.686996574, 9.067651543, 11.27232798, 34.21261395, -4.432344642, 13.53554684, -5.686992759, 9.067657265, 11.27232782, 34.21261395, 8.823854241, 20.98554546, 33.43569744, 9.869653496, 22.26509029, 34.27734936, 9.067655358, 11.27232702, 34.21260632, 7.891103539, 22.0309909, 34.45376766, 9.067657265, 11.27232784, 34.21262157, 7.050761971, 11.27232867, 34.39245785, 7.891105446, 22.03098994, 34.45378292, -4.432345119, 13.53554636, -5.686994667, 9.067651543, 11.27232846, -0.5373889158, 9.067651543, 11.2723285, 34.21261395, 9.067649635, 11.27232678, -0.5373860547, 9.067649635, 10.02232486, -0.5373860547, 9.067649635, 11.27232679, 34.21261776, 9.067651543, 10.02232486, -0.5373860547, 9.067651543, 10.02232486, 34.21261776, 9.067651543, 11.2723268, 34.21261776, 9.067649635, 10.02232867, -0.5373831937, 7.067649635, 10.02232867, -0.5373831937, 9.067649635, 10.02232867, 34.21262157, 7.067649635, 10.02232879, -0.5373831937, 7.067649635, 10.02232879, 34.21262157, 9.067649635, 10.02232879, 34.21262157],
            [0.845094, -0.453722, -0.282759, 0.845094, -0.453722, -0.282759, 0.845094, -0.453722, -0.282759, 0.845091, -0.453731, -0.282755, 0.845091, -0.453731, -0.282755, 0.845091, -0.453731, -0.282755, 0.674702, -0.706690, -0.212994, 0.674702, -0.706690, -0.212994, 0.674702, -0.706690, -0.212994, 0.674704, -0.706687, -0.212999, 0.674704, -0.706687, -0.212999, 0.674704, -0.706687, -0.212999, 0.438278, -0.890468, -0.122391, 0.438278, -0.890468, -0.122391, 0.438278, -0.890468, -0.122391, 0.438275, -0.890469, -0.122392, 0.438275, -0.890469, -0.122392, 0.438275, -0.890469, -0.122392, 0.158947, -0.987088, -0.019803, 0.158947, -0.987088, -0.019803, 0.158947, -0.987088, -0.019803, 0.158946, -0.987089, -0.019799, 0.158946, -0.987089, -0.019799, 0.158946, -0.987089, -0.019799, -0.135938, -0.987088, 0.084721, -0.135938, -0.987088, 0.084721, -0.135938, -0.987088, 0.084721, -0.135938, -0.987088, 0.084726, -0.135938, -0.987088, 0.084726, -0.135938, -0.987088, 0.084726, -0.417519, -0.890468, 0.180955, -0.417519, -0.890468, 0.180955, -0.417519, -0.890468, 0.180955, -0.417513, -0.890470, 0.180959, -0.417513, -0.890470, 0.180959, -0.417513, -0.890470, 0.180959, -0.658237, -0.706678, 0.259481, -0.658237, -0.706678, 0.259481, -0.658237, -0.706678, 0.259481, -0.658228, -0.706688, 0.259475, -0.658228, -0.706688, 0.259475, -0.658228, -0.706688, 0.259475, -0.834515, -0.453726, 0.312597, -0.834515, -0.453726, 0.312597, -0.834515, -0.453726, 0.312597, -0.834518, -0.453721, 0.312596, -0.834518, -0.453721, 0.312596, -0.834518, -0.453721, 0.312596, -0.929113, -0.156346, 0.335120, -0.929113, -0.156346, 0.335120, -0.929113, -0.156346, 0.335120, -0.929111, -0.156344, 0.335126, -0.929111, -0.156344, 0.335126, -0.929111, -0.156344, 0.335126, -0.932756, 0.156347, 0.324840, -0.932756, 0.156347, 0.324840, -0.932756, 0.156347, 0.324840, -0.932758, 0.156341, 0.324839, -0.932758, 0.156341, 0.324839, -0.932758, 0.156341, 0.324839, -0.845089, 0.453734, 0.282754, -0.845089, 0.453734, 0.282754, -0.845089, 0.453734, 0.282754, -0.845091, 0.453730, 0.282756, -0.845091, 0.453730, 0.282756, -0.845091, 0.453730, 0.282756, -0.674712, 0.706680, 0.212997, -0.674712, 0.706680, 0.212997, -0.674712, 0.706680, 0.212997, -0.674705, 0.706686, 0.212996, -0.674705, 0.706686, 0.212996, -0.674705, 0.706686, 0.212996, -0.438268, 0.890473, 0.122387, -0.438268, 0.890473, 0.122387, -0.438268, 0.890473, 0.122387, -0.438272, 0.890472, 0.122385, -0.438272, 0.890472, 0.122385, -0.438272, 0.890472, 0.122385, -0.158948, 0.987088, 0.019802, -0.158948, 0.987088, 0.019802, -0.158948, 0.987088, 0.019802, -0.158943, 0.987089, 0.019800, -0.158943, 0.987089, 0.019800, -0.158943, 0.987089, 0.019800, 0.135939, 0.987088, -0.084725, 0.135939, 0.987088, -0.084725, 0.135939, 0.987088, -0.084725, 0.135932, 0.987089, -0.084722, 0.135932, 0.987089, -0.084722, 0.135932, 0.987089, -0.084722, 0.417509, 0.890472, -0.180955, 0.417509, 0.890472, -0.180955, 0.417509, 0.890472, -0.180955, 0.417517, 0.890470, -0.180951, 0.417517, 0.890470, -0.180951, 0.417517, 0.890470, -0.180951, 0.658232, 0.706685, -0.259476, 0.658232, 0.706685, -0.259476, 0.658232, 0.706685, -0.259476, 0.658227, 0.706688, -0.259479, 0.658227, 0.706688, -0.259479, 0.658227, 0.706688, -0.259479, 0.834519, 0.453718, -0.312599, 0.834519, 0.453718, -0.312599, 0.834519, 0.453718, -0.312599, 0.834512, 0.453732, -0.312597, 0.834512, 0.453732, -0.312597, 0.834512, 0.453732, -0.312597, 0.929111, 0.156354, -0.335122, 0.929111, 0.156354, -0.335122, 0.929111, 0.156354, -0.335122, 0.929112, 0.156349, -0.335122, 0.929112, 0.156349, -0.335122, 0.929112, 0.156349, -0.335122, 0.932757, -0.156346, -0.324839, 0.932757, -0.156346, -0.324839, 0.932757, -0.156346, -0.324839, 0.932756, -0.156353, -0.324840, 0.932756, -0.156353, -0.324840, 0.932756, -0.156353, -0.324840, 0.890128, -0.396964, -0.223810, 0.890128, -0.396964, -0.223810, 0.890128, -0.396964, -0.223810, 0.890130, -0.396961, -0.223811, 0.890130, -0.396961, -0.223811, 0.890130, -0.396961, -0.223811, 0.706451, -0.631170, -0.320238, 0.706451, -0.631170, -0.320238, 0.706451, -0.631170, -0.320238, 0.706449, -0.631172, -0.320238, 0.706449, -0.631172, -0.320238, 0.706449, -0.631172, -0.320238, 0.453613, -0.803597, -0.385315, 0.453613, -0.803597, -0.385315, 0.453613, -0.803597, -0.385315, 0.453613, -0.803596, -0.385317, 0.453613, -0.803596, -0.385317, 0.453613, -0.803596, -0.385317, 0.156377, -0.897355, -0.412675, 0.156377, -0.897355, -0.412675, 0.156377, -0.897355, -0.412675, 0.156373, -0.897355, -0.412676, 0.156373, -0.897355, -0.412676, 0.156373, -0.897355, -0.412676, -0.156171, -0.903272, -0.399638, -0.156171, -0.903272, -0.399638, -0.156171, -0.903272, -0.399638, -0.156168, -0.903272, -0.399640, -0.156168, -0.903272, -0.399640, -0.156168, -0.903272, -0.399640, -0.453427, -0.820768, -0.347483, -0.453427, -0.820768, -0.347483, -0.453427, -0.820768, -0.347483, -0.453420, -0.820772, -0.347483, -0.453420, -0.820772, -0.347483, -0.453420, -0.820772, -0.347483, -0.706291, -0.657927, -0.261314, -0.706291, -0.657927, -0.261314, -0.706291, -0.657927, -0.261314, -0.706290, -0.657928, -0.261314, -0.706290, -0.657928, -0.261314, -0.706290, -0.657928, -0.261314, -0.890024, -0.430683, -0.149565, -0.890024, -0.430683, -0.149565, -0.890024, -0.430683, -0.149565, -0.890027, -0.430676, -0.149565, -0.890027, -0.430676, -0.149565, -0.890027, -0.430676, -0.149565, -0.986635, -0.161289, -0.023179, -0.986635, -0.161289, -0.023179, -0.986635, -0.161289, -0.023179, -0.986635, -0.161289, -0.023179, -0.986635, -0.161289, -0.023179, -0.986635, -0.161289, -0.023179, -0.986672, 0.123904, 0.105479, -0.986672, 0.123904, 0.105479, -0.986672, 0.123904, 0.105479, -0.986673, 0.123897, 0.105478, -0.986673, 0.123897, 0.105478, -0.986673, 0.123897, 0.105478, -0.890126, 0.396969, 0.223812, -0.890126, 0.396969, 0.223812, -0.890126, 0.396969, 0.223812, -0.890129, 0.396962, 0.223811, -0.890129, 0.396962, 0.223811, -0.890129, 0.396962, 0.223811, -0.706451, 0.631171, 0.320236, -0.706451, 0.631171, 0.320236, -0.706451, 0.631171, 0.320236, -0.706450, 0.631170, 0.320238, -0.706450, 0.631170, 0.320238, -0.706450, 0.631170, 0.320238, -0.453611, 0.803597, 0.385316, -0.453611, 0.803597, 0.385316, -0.453611, 0.803597, 0.385316, -0.453615, 0.803594, 0.385318, -0.453615, 0.803594, 0.385318, -0.453615, 0.803594, 0.385318, -0.156373, 0.897354, 0.412677, -0.156373, 0.897354, 0.412677, -0.156373, 0.897354, 0.412677, -0.156375, 0.897355, 0.412675, -0.156375, 0.897355, 0.412675, -0.156375, 0.897355, 0.412675, 0.156165, 0.903272, 0.399641, 0.156165, 0.903272, 0.399641, 0.156165, 0.903272, 0.399641, 0.156170, 0.903271, 0.399641, 0.156170, 0.903271, 0.399641, 0.156170, 0.903271, 0.399641, 0.453426, 0.820768, 0.347483, 0.453426, 0.820768, 0.347483, 0.453426, 0.820768, 0.347483, 0.453427, 0.820768, 0.347483, 0.453427, 0.820768, 0.347483, 0.453427, 0.820768, 0.347483, 0.706290, 0.657929, 0.261313, 0.706290, 0.657929, 0.261313, 0.706290, 0.657929, 0.261313, 0.706294, 0.657924, 0.261313, 0.706294, 0.657924, 0.261313, 0.706294, 0.657924, 0.261313, 0.890022, 0.430687, 0.149565, 0.890022, 0.430687, 0.149565, 0.890022, 0.430687, 0.149565, 0.890025, 0.430680, 0.149567, 0.890025, 0.430680, 0.149567, 0.890025, 0.430680, 0.149567, 0.986635, 0.161287, 0.023179, 0.986635, 0.161287, 0.023179, 0.986635, 0.161287, 0.023179, 0.986634, 0.161292, 0.023179, 0.986634, 0.161292, 0.023179, 0.986634, 0.161292, 0.023179, 0.986673, -0.123901, -0.105478, 0.986673, -0.123901, -0.105478, 0.986673, -0.123901, -0.105478, 0.986673, -0.123896, -0.105479, 0.986673, -0.123896, -0.105479, 0.986673, -0.123896, -0.105479, 0.000000, 0.915486, 0.402350, 0.000000, 0.915486, 0.402350, 0.000000, 0.915486, 0.402350, -0.000000, 0.915486, 0.402350, -0.000000, 0.915486, 0.402350, -0.000000, 0.915486, 0.402350, 0.000000, -0.402559, 0.915394, 0.000000, -0.402559, 0.915394, 0.000000, -0.402559, 0.915394, 0.001720, -0.386296, 0.922373, 0.001720, -0.386296, 0.922373, 0.001720, -0.386296, 0.922373, -0.935149, 0.020211, 0.353678, -0.935149, 0.020211, 0.353678, -0.935149, 0.020211, 0.353678, -0.999115, 0.038346, 0.017299, -0.999115, 0.038346, 0.017299, -0.999115, 0.038346, 0.017299, -0.998746, -0.000288, 0.050059, -0.998746, -0.000288, 0.050059, -0.998746, -0.000288, 0.050059, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, 0.001793, -0.913744, -0.406286, 0.001793, -0.913744, -0.406286, 0.001793, -0.913744, -0.406286, -0.000767, -0.911537, -0.411216, -0.000767, -0.911537, -0.411216, -0.000767, -0.911537, -0.411216, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -0.000000, 0.913806, 0.406152, -0.000000, 0.913806, 0.406152, -0.000000, 0.913806, 0.406152, 0.000000, 0.913806, 0.406152, 0.000000, 0.913806, 0.406152, 0.000000, 0.913806, 0.406152, -0.959122, 0.024484, 0.281930, -0.959122, 0.024484, 0.281930, -0.959122, 0.024484, 0.281930, -0.941215, 0.066719, 0.331154, -0.941215, 0.066719, 0.331154, -0.941215, 0.066719, 0.331154, -0.941215, 0.066718, 0.331154, -0.941215, 0.066718, 0.331154, -0.941215, 0.066718, 0.331154, -0.946634, 0.022154, 0.321549, -0.946634, 0.022154, 0.321549, -0.946634, 0.022154, 0.321549, -0.947214, 0.001868, 0.320595, -0.947214, 0.001868, 0.320595, -0.947214, 0.001868, 0.320595, -0.090267, 0.012451, -0.995840, -0.090267, 0.012451, -0.995840, -0.090267, 0.012451, -0.995840, -0.088804, 0.012614, -0.995969, -0.088804, 0.012614, -0.995969, -0.088804, 0.012614, -0.995969, -0.165338, -0.986237, 0.000000, -0.165338, -0.986237, 0.000000, -0.165338, -0.986237, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, -0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, -1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 1.000000, 0.000000]
        // 
            );
        //STD_DRAWINGS["PARENT"] = STD_DRAWINGS_Module_Pattern(
        //Vertex Positions
        // [],
        //Vertex Normals
        // []
        //  );
        //Pull from aspx/php off sql maximo db, without server permissions here is raw data

        //ASSETS[00001] = ASSETS_Module_Pattern("NAME","SSF1-1", "DRI-34","PARENT#","OPERATING", 3.0, 5.0);
        //ASSETS[00002] = ASSETS_Module_Pattern("NAME","SSF1-1","TAI-10","PARENT#","OPERATING", 20.9, 1.0);
        ASSETS[1] = ASSETS_Module_Pattern("SSF3-5TRA-M", "SSF3-5", "TRA-M", "", "OPERATING", 0.0, -10);
        /*ASSETS[740144] = ASSETS_Module_Pattern("MF4-2TAI-02"     ,"MF4-2"    ,"TAI-02"   ,"740052","OPERATING",0,0);
        ASSETS[740145] = ASSETS_Module_Pattern("MF4-2DRI-12"     ,"MF4-2"    ,"DRI-12"   ,"740052","OPERATING",11241.4749,0);
        ASSETS[740146] = ASSETS_Module_Pattern("MF4-2HIT-08"     ,"MF4-2"    ,"HIT-08"   ,"740052","OPERATING",0,0);
        ASSETS[740147] = ASSETS_Module_Pattern("MF1-2NOS-01"     ,"MF1-2"    ,"NOS-01"   ,"740053","OPERATING",0,0);
        ASSETS[740148] = ASSETS_Module_Pattern("MF1-2TAI-02"     ,"MF1-2"    ,"TAI-02"   ,"740053","OPERATING",0,0);
        ASSETS[740149] = ASSETS_Module_Pattern("MF1-2DRI-12"     ,"MF1-2"    ,"DRI-12"   ,"740053","OPERATING",0,0);
        ASSETS[740150] = ASSETS_Module_Pattern("MF1-2HIT-08"     ,"MF1-2"    ,"HIT-08"   ,"740053","OPERATING",0,0);
        ASSETS[740151] = ASSETS_Module_Pattern("MF2-1TAI-02"     ,"MF2-1"    ,"TAI-02"   ,"740054","OPERATING",0,0);
        ASSETS[740152] = ASSETS_Module_Pattern("MF2-1DRI-07"     ,"MF2-1"    ,"DRI-07"   ,"740054","OPERATING",0,0);
        ASSETS[740153] = ASSETS_Module_Pattern("MF1-1TAI-02"     ,"MF1-1"    ,"TAI-02"   ,"740055","OPERATING",0,0);
        ASSETS[740154] = ASSETS_Module_Pattern("MF1-1DRI-21"     ,"MF1-1"    ,"DRI-21"   ,"740055","OPERATING",0,0);
        ASSETS[740155] = ASSETS_Module_Pattern("PS1-2TAI-01"     ,"PS1-2"    ,"TAI-01"   ,"740056","OPERATING",0,0);
        ASSETS[740156] = ASSETS_Module_Pattern("PS1-2DRI-21BB"   ,"PS1-2"    ,"DRI-21BB" ,"740056","OPERATING",14810.9839,0);
        ASSETS[740157] = ASSETS_Module_Pattern("MF3-1TAI-03"     ,"MF3-1"    ,"TAI-03"   ,"740057","OPERATING",0,0);
        ASSETS[740158] = ASSETS_Module_Pattern("MF3-1DRI-21BB"   ,"MF3-1"    ,"DRI-21BB" ,"740057","OPERATING",0,0);
        ASSETS[740159] = ASSETS_Module_Pattern("PS1-1NOS-01"     ,"PS1-1"    ,"NOS-01"   ,"740058","OPERATING",0,0);
        ASSETS[740160] = ASSETS_Module_Pattern("PS1-1TAI-02"     ,"PS1-1"    ,"TAI-02"   ,"740058","OPERATING",12254.9239,0);
        ASSETS[740161] = ASSETS_Module_Pattern("PS1-1DRI-21BB"   ,"PS1-1"    ,"DRI-21BB" ,"740058","OPERATING",14645.9239,0);
        ASSETS[740162] = ASSETS_Module_Pattern("MF4-1TAI-02"     ,"MF4-1"    ,"TAI-02"   ,"740059","OPERATING",0,0);
        ASSETS[740163] = ASSETS_Module_Pattern("MF4-1DRI-21"     ,"MF4-1"    ,"DRI-21"   ,"740059","OPERATING",0,0);
        ASSETS[740164] = ASSETS_Module_Pattern("SSF1-1TAI-02"    ,"SSF1-1"   ,"TAI-02"   ,"740060","OPERATING",0,0);
        ASSETS[740165] = ASSETS_Module_Pattern("SSF1-1DRI-21"    ,"SSF1-1"   ,"DRI-21"   ,"740060","OPERATING",12292.1749,0);
        ASSETS[740025] = ASSETS_Module_Pattern("UNL1-2PARENT"    ,"UNL1-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740026] = ASSETS_Module_Pattern("UNL2-2PARENT"    ,"UNL2-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740027] = ASSETS_Module_Pattern("UNL3-2PARENT"    ,"UNL3-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740028] = ASSETS_Module_Pattern("UNL4-2PARENT"    ,"UNL4-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740029] = ASSETS_Module_Pattern("UNL5-2PARENT"    ,"UNL5-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740030] = ASSETS_Module_Pattern("UNL6-2PARENT"    ,"UNL6-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740031] = ASSETS_Module_Pattern("UNL7-2PARENT"    ,"UNL7-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740032] = ASSETS_Module_Pattern("UNL8-2PARENT"    ,"UNL8-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740033] = ASSETS_Module_Pattern("UNL9-2PARENT"    ,"UNL9-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740034] = ASSETS_Module_Pattern("UNL10-2PARENT"   ,"UNL10-2"  ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740035] = ASSETS_Module_Pattern("UNL11-2PARENT"   ,"UNL11-2"  ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740036] = ASSETS_Module_Pattern("MF1-3PARENT"     ,"MF1-3"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740037] = ASSETS_Module_Pattern("MF2-2PARENT"     ,"MF2-2"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740038] = ASSETS_Module_Pattern("MF3-2PARENT"     ,"MF3-2"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740039] = ASSETS_Module_Pattern("MF4-3PARENT"     ,"MF4-3"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740040] = ASSETS_Module_Pattern("M1RO1-1PARENT"   ,"M1RO1-1"  ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740041] = ASSETS_Module_Pattern("M2RO1-1PARENT"   ,"M2RO1-1"  ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740042] = ASSETS_Module_Pattern("M3RO1-1PARENT"   ,"M3RO1-1"  ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740043] = ASSETS_Module_Pattern("M4RO1-1PARENT"   ,"M4RO1-1"  ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740044] = ASSETS_Module_Pattern("SSF1-2PARENT"    ,"SSF1-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740045] = ASSETS_Module_Pattern("SSR1-2PARENT"    ,"SSR1-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740046] = ASSETS_Module_Pattern("SSR1-1APARENT"   ,"SSR1-1A"  ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740047] = ASSETS_Module_Pattern("SSR1-1BPARENT"   ,"SSR1-1B"  ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740048] = ASSETS_Module_Pattern("SSRO-1PARENT"    ,"SSRO-1"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740049] = ASSETS_Module_Pattern("SSRO-2PARENT"    ,"SSRO-2"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740050] = ASSETS_Module_Pattern("SSRO-3PARENT"    ,"SSRO-3"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740051] = ASSETS_Module_Pattern("SSR1-3PARENT"    ,"SSR1-3"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740052] = ASSETS_Module_Pattern("MF4-2PARENT"     ,"MF4-2"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740053] = ASSETS_Module_Pattern("MF1-2PARENT"     ,"MF1-2"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740054] = ASSETS_Module_Pattern("MF2-1PARENT"     ,"MF2-1"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740055] = ASSETS_Module_Pattern("MF1-1PARENT"     ,"MF1-1"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740056] = ASSETS_Module_Pattern("PS1-2PARENT"     ,"PS1-2"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740057] = ASSETS_Module_Pattern("MF3-1PARENT"     ,"MF3-1"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740058] = ASSETS_Module_Pattern("PS1-1PARENT"     ,"PS1-1"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740059] = ASSETS_Module_Pattern("MF4-1PARENT"     ,"MF4-1"    ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740060] = ASSETS_Module_Pattern("SSF1-1PARENT"    ,"SSF1-1"   ,"PARENT"   ,""      ,"OPERATING",0,0);
        ASSETS[740061] = ASSETS_Module_Pattern("EXT-1UNL-53"     ,"EXT-1"    ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740062] = ASSETS_Module_Pattern("EXT-2UNL-53"     ,"EXT-2"    ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740063] = ASSETS_Module_Pattern("EXT-3UNL-53"     ,"EXT-3"    ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740064] = ASSETS_Module_Pattern("EXT-4UNL-53"     ,"EXT-4"    ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740065] = ASSETS_Module_Pattern("EXT-5UNL-53"     ,"EXT-5"    ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740066] = ASSETS_Module_Pattern("EXT-6UNL-53"     ,"EXT-6"    ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740067] = ASSETS_Module_Pattern("EXT-7UNL-53"     ,"EXT-7"    ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740068] = ASSETS_Module_Pattern("EXT-8UNL-53"     ,"EXT-8"    ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740069] = ASSETS_Module_Pattern("EXT-9UNL-53"     ,"EXT-9"    ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740070] = ASSETS_Module_Pattern("EXT-10UNL-53"    ,"EXT-10"   ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740071] = ASSETS_Module_Pattern("EXT-11UNL-53"    ,"EXT-11"   ,"UNL-53"   ,""      ,"OPERATING",0,0);
        ASSETS[740074] = ASSETS_Module_Pattern("UNL1-2NOS-01"    ,"UNL1-2"   ,"NOS-01"   ,"740025","OPERATING",12621.6098,0);//
        ASSETS[740075] = ASSETS_Module_Pattern("UNL1-2TAI-10"    ,"UNL1-2"   ,"TAI-10"   ,"740025","OPERATING",12621.4678,0);//
        ASSETS[740076] = ASSETS_Module_Pattern("UNL1-2DRI-34"    ,"UNL1-2"   ,"DRI-34"   ,"740025","OPERATING",12621.7729,0);//
        ASSETS[740077] = ASSETS_Module_Pattern("UNL2-2NOS-01"    ,"UNL2-2"   ,"NOS-01"   ,"740026","OPERATING",12776.6098,0);
        ASSETS[740078] = ASSETS_Module_Pattern("UNL2-2TAI-10"    ,"UNL2-2"   ,"TAI-10"   ,"740026","OPERATING",12776.4678,0);
        ASSETS[740079] = ASSETS_Module_Pattern("UNL2-2DRI-34"    ,"UNL2-2"   ,"DRI-34"   ,"740026","OPERATING",12776.7729,0);//
        ASSETS[740080] = ASSETS_Module_Pattern("UNL3-2NOS-01"    ,"UNL3-2"   ,"NOS-01"   ,"740027","OPERATING",12932.6098,0);
        ASSETS[740081] = ASSETS_Module_Pattern("UNL3-2TAI-10"    ,"UNL3-2"   ,"TAI-10"   ,"740027","OPERATING",12932.4678,0);
        ASSETS[740082] = ASSETS_Module_Pattern("UNL3-2DRI-34"    ,"UNL3-2"   ,"DRI-34"   ,"740027","OPERATING",12932.7729,0);//
        ASSETS[740083] = ASSETS_Module_Pattern("UNL4-2NOS-01"    ,"UNL4-2"   ,"NOS-01"   ,"740028","OPERATING",13088.6098,0);
        ASSETS[740084] = ASSETS_Module_Pattern("UNL4-2TAI-10"    ,"UNL4-2"   ,"TAI-10"   ,"740028","OPERATING",13088.4678,0);
        ASSETS[740085] = ASSETS_Module_Pattern("UNL4-2DRI-34"    ,"UNL4-2"   ,"DRI-34"   ,"740028","OPERATING",13088.7729,0);//
        ASSETS[740086] = ASSETS_Module_Pattern("UNL5-2NOS-01"    ,"UNL5-2"   ,"NOS-01"   ,"740029","OPERATING",13244.6098,0);//
        ASSETS[740087] = ASSETS_Module_Pattern("UNL5-2TAI-10"    ,"UNL5-2"   ,"TAI-10"   ,"740029","OPERATING",13244.4678,0);//
        ASSETS[740088] = ASSETS_Module_Pattern("UNL5-2DRI-34"    ,"UNL5-2"   ,"DRI-34"   ,"740029","OPERATING",13244.7729,0);//
        ASSETS[740089] = ASSETS_Module_Pattern("UNL6-2NOS-01"    ,"UNL6-2"   ,"NOS-01"   ,"740030","OPERATING",13556.6098,0);
        ASSETS[740090] = ASSETS_Module_Pattern("UNL6-2TAI-10"    ,"UNL6-2"   ,"TAI-10"   ,"740030","OPERATING",13556.4678,0);
        ASSETS[740091] = ASSETS_Module_Pattern("UNL6-2DRI-34"    ,"UNL6-2"   ,"DRI-34"   ,"740030","OPERATING",13556.7729,0);
        ASSETS[740092] = ASSETS_Module_Pattern("UNL7-2NOS-01"    ,"UNL7-2"   ,"NOS-01"   ,"740031","OPERATING",0,0);
        ASSETS[740093] = ASSETS_Module_Pattern("UNL7-2TAI-10"    ,"UNL7-2"   ,"TAI-10"   ,"740031","OPERATING",0,0);
        ASSETS[740094] = ASSETS_Module_Pattern("UNL7-2DRI-34"    , "UNL7-2"  ,"DRI-34"   ,"740031","OPERATING",0,0);
        ASSETS[740095] = ASSETS_Module_Pattern("UNL8-2NOS-01"    , "UNL8-2"  ,"NOS-01"   ,"740032","OPERATING",0,0);
        ASSETS[740096] = ASSETS_Module_Pattern("UNL8-2TAI-10"    , "UNL8-2"  ,"TAI-10"   ,"740032","OPERATING",0,0);
        ASSETS[740097] = ASSETS_Module_Pattern("UNL8-2DRI-34"    , "UNL8-2"  ,"DRI-34"   ,"740032","OPERATING",0,0);
        ASSETS[740098] = ASSETS_Module_Pattern("UNL9-2NOS-01"    , "UNL9-2"  ,"NOS-01"   ,"740033","OPERATING",0,0);
        ASSETS[740099] = ASSETS_Module_Pattern("UNL9-2TAI-10"    , "UNL9-2"  ,"TAI-10"   ,"740033","OPERATING",0,0);
        ASSETS[740100] = ASSETS_Module_Pattern("UNL9-2DRI-34"    , "UNL9-2"  ,"DRI-34"   ,"740033","OPERATING",0,0);
        ASSETS[740101] = ASSETS_Module_Pattern("UNL10-2NOS-01"   ,"UNL10-2"  ,"NOS-01"   ,"740034","OPERATING",0,0);
        ASSETS[740102] = ASSETS_Module_Pattern("UNL10-2TAI-10"   ,"UNL10-2"  ,"TAI-10"   ,"740034","OPERATING",0,0);
        ASSETS[740103] = ASSETS_Module_Pattern("UNL10-2DRI-34"   ,"UNL10-2"  ,"DRI-34"   ,"740034","OPERATING",0,0);
        ASSETS[740104] = ASSETS_Module_Pattern("UNL11-2NOS-01"   ,"UNL11-2"  ,"NOS-01"   ,"740035","OPERATING",0,0);
        ASSETS[740105] = ASSETS_Module_Pattern("UNL11-2TAI-10"   ,"UNL11-2"  ,"TAI-10"   ,"740035","OPERATING",0,0);
        ASSETS[740106] = ASSETS_Module_Pattern("UNL11-2DRI-34"   ,"UNL11-2"  ,"DRI-34"   ,"740035","OPERATING",0,0);
        ASSETS[740107] = ASSETS_Module_Pattern("MF1-3NOS-01"     ,"MF1-3"    ,"NOS-01"   ,"740036","OPERATING",0,0);
        ASSETS[740108] = ASSETS_Module_Pattern("MF1-3TAI-02"     ,"MF1-3"    ,"TAI-02"   ,"740036","OPERATING",0,0);
        ASSETS[740109] = ASSETS_Module_Pattern("MF1-3DRI-34"     ,"MF1-3"    ,"DRI-34"   ,"740036","OPERATING",0,0);
        ASSETS[740110] = ASSETS_Module_Pattern("MF2-2TAI-02"     ,"MF2-2"    ,"TAI-02"   ,"740037","OPERATING",0,0);
        ASSETS[740111] = ASSETS_Module_Pattern("MF2-2DRI-34"     ,"MF2-2"    ,"DRI-34"   ,"740037","OPERATING",0,0);
        ASSETS[740112] = ASSETS_Module_Pattern("MF3-2TAI-02"     ,"MF3-2"    ,"TAI-02"   ,"740038","OPERATING",0,0);
        ASSETS[740113] = ASSETS_Module_Pattern("MF3-2DRI-34"     ,"MF3-2"    ,"DRI-34"   ,"740038","OPERATING",0,0);
        ASSETS[740114] = ASSETS_Module_Pattern("MF4-3NOS-01"     ,"MF4-3"    ,"NOS-01"   ,"740039","OPERATING",0,0);
        ASSETS[740115] = ASSETS_Module_Pattern("MF4-3TAI-02"     ,"MF4-3"    ,"TAI-02"   ,"740039","OPERATING",0,0);
        ASSETS[740116] = ASSETS_Module_Pattern("MF4-3DRI-34"     ,"MF4-3"    ,"DRI-34"   ,"740039","OPERATING",0,0);
        ASSETS[740117] = ASSETS_Module_Pattern("M1RO1-1TAI-10"   ,"M1RO1-1"  ,"TAI-10"   ,"740040","OPERATING",16012.5678,0);
        ASSETS[740118] = ASSETS_Module_Pattern("M1RO1-1DRI-12"   ,"M1RO1-1"  ,"DRI-12"   ,"740040","OPERATING",16997.5678,0);
        ASSETS[740119] = ASSETS_Module_Pattern("M2RO1-1TAI-10"   ,"M2RO1-1"  ,"TAI-10"   ,"740041","OPERATING",0,0);
        ASSETS[740120] = ASSETS_Module_Pattern("M2RO1-1DRI-12"   ,"M2RO1-1"  ,"DRI-12"   ,"740041","OPERATING",0,0);
        ASSETS[740121] = ASSETS_Module_Pattern("M3RO1-1TAI-10"   ,"M3RO1-1"  ,"TAI-10"   ,"740042","OPERATING",12396.5678,0);
        ASSETS[740122] = ASSETS_Module_Pattern("M3RO1-1DRI-12"   ,"M3RO1-1"  ,"DRI-12"   ,"740042","OPERATING",11302.5678,0);
        ASSETS[740123] = ASSETS_Module_Pattern("M4RO1-1TAI-10"   ,"M4RO1-1"  ,"TAI-10"   ,"740043","OPERATING",11111.5678,0);
        ASSETS[740124] = ASSETS_Module_Pattern("M4RO1-1DRI-12"   ,"M4RO1-1"  ,"DRI-12"   ,"740043","OPERATING",10051.5678,0);
        ASSETS[740126] = ASSETS_Module_Pattern("SSF1-2TAI-02"    ,"SSF1-2"   ,"TAI-02"   ,"740044","OPERATING",0,0);
        ASSETS[740127] = ASSETS_Module_Pattern("SSF1-2DRI-12"    ,"SSF1-2"   ,"DRI-12"   ,"740044","OPERATING",0,0);
        ASSETS[740128] = ASSETS_Module_Pattern("SSR1-2NOS-01"	,"SSR1-2"	,"NOS-01"	,"740045","OPERATING",0,0);
        ASSETS[740129] = ASSETS_Module_Pattern("SSR1-2TAI-02"	,"SSR1-2"	,"TAI-02"	,"740045","OPERATING",11499.40501,0);
        ASSETS[740130] = ASSETS_Module_Pattern("SSR1-2DRI-12"	,"SSR1-2"	,"DRI-12"	,"740045","OPERATING",11499.6049,0);
        ASSETS[740131] = ASSETS_Module_Pattern("SSR1-1ATAI-10"	,"SSR1-1A"	,"TAI-10"	,"740046","OPERATING",12038.0299,0);
        ASSETS[740132] = ASSETS_Module_Pattern("SSR1-1ADRI-34"	,"SSR1-1A"	,"DRI-34"	,"740046","OPERATING",11567.0299,0);
        ASSETS[740133] = ASSETS_Module_Pattern("SSR1-1BTAI-10"	,"SSR1-1B"	,"TAI-10"	,"740047","OPERATING",12038.65401,0);
        ASSETS[740134] = ASSETS_Module_Pattern("SSR1-1BDRI-34"	,"SSR1-1B"	,"DRI-34"	,"740047","OPERATING",11567.65401,0);
        ASSETS[740135] = ASSETS_Module_Pattern("SSRO-1TAI-16"	,"SSRO-1"	,"TAI-16"	,"740048","OPERATING",0,0);
        ASSETS[740136] = ASSETS_Module_Pattern("SSRO-1DRI-44"	,"SSRO-1"	,"DRI-44"	,"740048","OPERATING",0,0);
        ASSETS[740137] = ASSETS_Module_Pattern("SSRO-2TAI-16"	,"SSRO-2"	,"TAI-16"	,"740049","OPERATING",0,0);
        ASSETS[740138] = ASSETS_Module_Pattern("SSRO-2DRI-44"	,"SSRO-2"	,"DRI-44"	,"740049","OPERATING",0,0);
        ASSETS[740139] = ASSETS_Module_Pattern("SSRO-3TAI-16"	,"SSRO-3"	,"TAI-16"	,"740050","OPERATING",0,0);
        ASSETS[740140] = ASSETS_Module_Pattern("SSRO-3DRI-44"	,"SSRO-3"	,"DRI-44"	,"740050","OPERATING",0,0);
        ASSETS[740141] = ASSETS_Module_Pattern("SSR1-3TAI-02"	,"SSR1-3"	,"TAI-02"	,"740051","OPERATING",0,0);
    */	ASSETS[740142] = ASSETS_Module_Pattern("SSR1-3DRI-43", "SSR1-3", "DRI-43", "740051", "OPERATING", 0, 0);
        /*	ASSETS[740143] = ASSETS_Module_Pattern("	MF4-2NOS-01	MF4-2	NOS-01	WASNR-BLDG1	740052	OPERATING	0376
            ASSETS[745232] = ASSETS_Module_Pattern("	LOA-201LOA-07DOOR201	LOA-201	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745233] = ASSETS_Module_Pattern("	LOA-202LOA-07DOOR202	LOA-202	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745234] = ASSETS_Module_Pattern("	LOA-203LOA-07DOOR203	LOA-203	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745235] = ASSETS_Module_Pattern("	LOA-204LOA-07DOOR204	LOA-204	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745236] = ASSETS_Module_Pattern("	LOA-205LOA-07DOOR205	LOA-205	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745237] = ASSETS_Module_Pattern("	LOA-206LOA-07DOOR206	LOA-206	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745238] = ASSETS_Module_Pattern("	LOA-207LOA-07DOOR207	LOA-207	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745239] = ASSETS_Module_Pattern("	LOA-208LOA-07DOOR208	LOA-208	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745240] = ASSETS_Module_Pattern("	LOA-209LOA-07DOOR209	LOA-209	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745241] = ASSETS_Module_Pattern("	LOA-210LOA-07DOOR210	LOA-210	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745242] = ASSETS_Module_Pattern("	LOA-211LOA-07DOOR211	LOA-211	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745243] = ASSETS_Module_Pattern("	LOA-212LOA-07DOOR212	LOA-212	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745244] = ASSETS_Module_Pattern("	LOA-213LOA-07DOOR213	LOA-213	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745245] = ASSETS_Module_Pattern("	LOA-214LOA-07DOOR214	LOA-214	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745246] = ASSETS_Module_Pattern("	LOA-215LOA-07DOOR215	LOA-215	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745247] = ASSETS_Module_Pattern("	LOA-216LOA-07DOOR216	LOA-216	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745248] = ASSETS_Module_Pattern("	LOA-217LOA-07DOOR217	LOA-217	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745249] = ASSETS_Module_Pattern("LOA-218LOA-07DOOR218	LOA-218	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745250] = ASSETS_Module_Pattern("LOA-219LOA-07DOOR219	LOA-219	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745251] = ASSETS_Module_Pattern("LOA-220LOA-07DOOR220	LOA-220	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745252] = ASSETS_Module_Pattern("LOA-221LOA-07DOOR221	LOA-221	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745253] = ASSETS_Module_Pattern("LOA-222LOA-07DOOR222	LOA-222	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745254] = ASSETS_Module_Pattern("LOA-223LOA-07DOOR223	LOA-223	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745255] = ASSETS_Module_Pattern("LOA-224LOA-07DOOR224	LOA-224	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745256] = ASSETS_Module_Pattern("LOA-225LOA-07DOOR225	LOA-225	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[745257] = ASSETS_Module_Pattern("LOA-226LOA-07DOOR226	LOA-226	LOA-07	WASNR-BLDG1		OPERATING	0376
            ASSETS[768884] = ASSETS_Module_Pattern("SLS-4SRCAMERA	SLS-CAM	CLAD-04	WASNR-BLDG1	759481	OPERATING	0376
            ASSETS[762938] = ASSETS_Module_Pattern("SSF3-1PARENT	SSF3-1	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759385] = ASSETS_Module_Pattern("SSF1-3PARENT	SSF1-3	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759389] = ASSETS_Module_Pattern("SSF2-1DRI-34	SSF2-1	DRI-34	WASNR-BLDG1	759388	OPERATING	0376
            ASSETS[763664] = ASSETS_Module_Pattern("SLS-4SRCOMPAXORTERDRI	SLS-4SR	SLS-CB-DRI	WASNR-BLDG1	759481	OPERATING	0376
            ASSETS[759524] = ASSETS_Module_Pattern("DAC-1DACAUTOMOTIVE	DAC-1	DAC	WASNR-BLDG1	759523	OPERATING	0376
            ASSETS[769975] = ASSETS_Module_Pattern("SSF3-1CHU-01	SSF3-1	CHU-01	WASNR-BLDG1	762938	OPERATING	0376
            ASSETS[770084] = ASSETS_Module_Pattern("SSRO1-1P1-1SOR-02A	SSRO1-1	SOR-02	WASNR-BLDG1	759482	OPERATING	0376
            ASSETS[770086] = ASSETS_Module_Pattern("	SSRO1-1P2-1SOR-02A	SSRO1-1	SOR-02	WASNR-BLDG1	759482	OPERATING	0376
            ASSETS[759390] = ASSETS_Module_Pattern("	SSF2-1TAI-10	SSF2-1	TAI-10	WASNR-BLDG1	759388	OPERATING	0376
            ASSETS[759391] = ASSETS_Module_Pattern("	SSF2-1NOS-01	SSF2-1	NOS-01	WASNR-BLDG1	759388	OPERATING	0376
            ASSETS[759392] = ASSETS_Module_Pattern("	SSF2-2PARENT	SSF2-2	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759393] = ASSETS_Module_Pattern("	SSF2-2DRI-34	SSF2-2	DRI-34	WASNR-BLDG1	759392	OPERATING	0376
            ASSETS[759394] = ASSETS_Module_Pattern("	SSF2-2TAI-10	SSF2-2	TAI-10	WASNR-BLDG1	759392	OPERATING	0376
            ASSETS[759403] = ASSETS_Module_Pattern("SSF3-3DRI-12	SSF3-3	DRI-12	WASNR-BLDG1	759402	OPERATING	0376
            ASSETS[759404] = ASSETS_Module_Pattern("SSF3-3TAI-10	SSF3-3	TAI-10	WASNR-BLDG1	759402	OPERATING	0376
            ASSETS[759405] = ASSETS_Module_Pattern("SSF3-3NOS-01	SSF3-3	NOS-01	WASNR-BLDG1	759402	OPERATING	0376
            ASSETS[759406] = ASSETS_Module_Pattern("SSF3-4PARENT	SSF3-4	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759407] = ASSETS_Module_Pattern("SSF3-4DRI-12	SSF3-4	DRI-12	WASNR-BLDG1	759406	OPERATING	0376
            ASSETS[759408] = ASSETS_Module_Pattern("SSF3-4TAI-10	SSF3-4	TAI-10	WASNR-BLDG1	759406	OPERATING	0376
            ASSETS[759409] = ASSETS_Module_Pattern("SSF3-4TAI-10	SSF3-4	TAI-10	WASNR-BLDG1	759406	OPERATING	0376
            ASSETS[759410] = ASSETS_Module_Pattern("SSF3-4NOS-01	SSF3-4	NOS-01	WASNR-BLDG1	759406	OPERATING	0376
            ASSETS[759411] = ASSETS_Module_Pattern("SLS-1PARENT	SLS-1	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759412] = ASSETS_Module_Pattern("SLS-1DRI-200	SLS-1	DRI-200	WASNR-BLDG1	759411	OPERATING	0376
            ASSETS[759413] = ASSETS_Module_Pattern("SS2F1-1PARENT	SS2F1-1	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759414] = ASSETS_Module_Pattern("SS2F1-1DRI-34	SS2F1-1	DRI-34	WASNR-BLDG1	759413	OPERATING	0376
            ASSETS[759415] = ASSETS_Module_Pattern("	SS2F1-1TAI-10	SS2F1-1	TAI-10	WASNR-BLDG1	759413	OPERATING	0376
            ASSETS[759416] = ASSETS_Module_Pattern("	SS2F1-1TAI-10	SS2F1-1	TAI-10	WASNR-BLDG1	759413	OPERATING	0376
            ASSETS[759417] = ASSETS_Module_Pattern("	SS2F1-2PARENT	SS2F1-2	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759418] = ASSETS_Module_Pattern("	SS2F1-2DRI-34	SS2F1-2	DRI-34	WASNR-BLDG1	759417	OPERATING	0376
            ASSETS[759419] = ASSETS_Module_Pattern("	SS2F1-2TAI-10	SS2F1-2	TAI-10	WASNR-BLDG1	759417	OPERATING	0376
            ASSETS[759420] = ASSETS_Module_Pattern("	SS2F1-2NOS-01	SS2F1-2	NOS-01	WASNR-BLDG1	759417	OPERATING	0376
            ASSETS[759421] = ASSETS_Module_Pattern("SS2F1-3PARENT	SS2F1-3	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759422] = ASSETS_Module_Pattern("SS2F1-3DRI-34	SS2F1-3	DRI-34	WASNR-BLDG1	759421	OPERATING	0376
            ASSETS[759423] = ASSETS_Module_Pattern("SS2F1-3TAI-10	SS2F1-3	TAI-10	WASNR-BLDG1	759421	OPERATING",0,0);
            ASSETS[769973] = ASSETS_Module_Pattern("SSF3-1TAI-10	SSF3-1	TAI-10	WASNR-BLDG1	762938	OPERATING	0376
            ASSETS[769948] = ASSETS_Module_Pattern("ELECTRICPALLETJACK	PALLETJACK	IRR-02	WASNR-BLDG1		OPERATING	0376
            759387] = ASSETS_Module_Pattern("SSF1-3TAI-10	SSF1-3	TAI-10	WASNR-BLDG1	759385	OPERATING	0376
            759397] = ASSETS_Module_Pattern("EXT-902UNL-54903	EXT-902	UNL-54	WASNR-BLDG1		OPERATING	0376
            759398] = ASSETS_Module_Pattern("SSF3-2PARENT	SSF3-2	PARENT	WASNR-BLDG1		OPERATING	0376
            759402] = ASSETS_Module_Pattern("SSF3-3PARENT	SSF3-3	PARENT	WASNR-BLDG1		OPERATING	0376
            752931] = ASSETS_Module_Pattern("SSF3-5VDC	SSF3-5	VDC-01	WASNR-BLDG1		OPERATING	0376
            759525] = ASSETS_Module_Pattern("DAC-2DACVDC	DAC-2	DAC	WASNR-BLDG1	759523	OPERATING	0376
            753048] = ASSETS_Module_Pattern("TRACTOR-RIRR-01	TRACTOR-R	IRR-01	WASNR-BLDG1		OPERATING	0376
            769981] = ASSETS_Module_Pattern("SS2F1-2CHU-01	SS2F1-2	CHU-01	WASNR-BLDG1	759417	OPERATING	0376
            770204] = ASSETS_Module_Pattern("DOOR-110DOORS02	DOOR-110	DOORS02	WASNR-BLDG1		OPERATING	0376
            770203] = ASSETS_Module_Pattern("DOOR-107DOORS02	DOOR-107	DOORS02	WASNR-BLDG1		OPERATING	0376
            770091] = ASSETS_Module_Pattern("GFGC-218GROUNDFAULT/GROUNDCONTINUITYPANEL	GFGC-218	ELECTRICAL	WASNR-BLDG1		OPERATING	0376
            759388] = ASSETS_Module_Pattern("SSF2-1PARENT	SSF2-1	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759386] = ASSETS_Module_Pattern("SSF1-3DRI-12	SSF1-3	DRI-12	WASNR-BLDG1	759385	OPERATING	0376
            759395] = ASSETS_Module_Pattern("SSF2-2NOS-01	SSF2-2	NOS-01	WASNR-BLDG1	759392	OPERATING	0376
            759523] = ASSETS_Module_Pattern("AIRCOMPRESSORPARENT	DAC	PARENT	WASNR-BLDG1		OPERATING	0376
            762940] = ASSETS_Module_Pattern("SSF1-0PARENT	SSF1-0	PARENT	WASNR-BLDG1		OPERATING	0376
            753047] = ASSETS_Module_Pattern("TRACTOR-PIRR-01	TRACTOR-P	IRR-01	WASNR-BLDG1		OPERATING	0376
            759396] = ASSETS_Module_Pattern("EXT-901UNL-54901	EXT-901	UNL-54	WASNR-BLDG1		OPERATING	0376
            770087] = ASSETS_Module_Pattern("SSRO1-1P2-2SOR-02A	SSRO1-1	SOR-02	WASNR-BLDG1	759482	OPERATING	0376
            770088] = ASSETS_Module_Pattern("DAC-3DACPE	DAC-3	DAC	WASNR-BLDG1	759523	OPERATING	0376
            768752] = ASSETS_Module_Pattern("	PZCART01IRR-03	IRRC-PZ-01	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            768753] = ASSETS_Module_Pattern("	PZCART02IRR-03	IRRC-PZ-02	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            768754] = ASSETS_Module_Pattern("	PZCART03IRR-03	IRRC-PZ-03	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            768755] = ASSETS_Module_Pattern("	PZCART04IRR-03	IRRC-PZ-04	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            768756] = ASSETS_Module_Pattern("	PZCART05IRR-03	IRRC-PZ-05	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            768757] = ASSETS_Module_Pattern("	PZCART06IRR-03	IRRC-PZ-06	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            768758] = ASSETS_Module_Pattern("	PZCART07IRR-03	IRRC-PZ-07	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            768759] = ASSETS_Module_Pattern("	PZCART08IRR-03	IRRC-PZ-08	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            768760] = ASSETS_Module_Pattern("	PZCART09IRR-03	IRRC-PZ-09	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            768761] = ASSETS_Module_Pattern("	PZCART10IRR-03	IRRC-PZ-10	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            768762] = ASSETS_Module_Pattern("	PZCART11IRR-03	IRRC-PZ-11	IRR-03	WASNR-BLDG1		OPERATING",0,0);
            769974] = ASSETS_Module_Pattern("	SSF3-1DRI-34	SSF3-1	DRI-34	WASNR-BLDG1	762938	OPERATING	0376
            759399] = ASSETS_Module_Pattern("	SSF3-2DRI-12BB	SSF3-2	DRI-12BB	WASNR-BLDG1	759398	OPERATING	0376
            759400] = ASSETS_Module_Pattern("	SSF3-2TAI-02	SSF3-2	TAI-02	WASNR-BLDG1	759398	OPERATING",0,0);
            759401] = ASSETS_Module_Pattern("SSF3-2NOS-01	SSF3-2	NOS-01	WASNR-BLDG1	759398	OPERATING",0,0);
            759476] = ASSETS_Module_Pattern("SSF3-6LFC	SSF3-6	LFC-01	WASNR-BLDG1		OPERATING",0,0);
            759477] = ASSETS_Module_Pattern("SLS-2PARENT	SLS-2	PARENT	WASNR-BLDG1		OPERATING",0,0);
            759478] = ASSETS_Module_Pattern("SLS-2DRI	SLS-2	DRI	WASNR-BLDG1	759477	OPERATING",0,0);
            759479] = ASSETS_Module_Pattern("SLS-3PARENT	SLS-3	PARENT	WASNR-BLDG1		OPERATING	0376
            759480] = ASSETS_Module_Pattern("SLS-3DRI	SLS-3	DRI	WASNR-BLDG1	759479	OPERATING	0376
            759481] = ASSETS_Module_Pattern("SLS-4SRCOMPAXORTER	SLS-4SR	SLS-CB-SORT	WASNR-BLDG1		OPERATING	0376
            759482] = ASSETS_Module_Pattern("SSRO1-1PARENT	SSRO1-1	PARENT	WASNR-BLDG1		OPERATING	0376
            759483] = ASSETS_Module_Pattern("SSRO1-1DRI-44	SSRO1-1	DRI-44	WASNR-BLDG1	759482	OPERATING	0376
            759484] = ASSETS_Module_Pattern("SSRO1-1TAI-10	SSRO1-1	TAI-10	WASNR-BLDG1	759482	OPERATING	0376
            759485] = ASSETS_Module_Pattern("SS2F2-1PARENT	SS2F2-1	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759486	SS2F2-1DRI-34	SS2F2-1	DRI-34	WASNR-BLDG1	759485	OPERATING	0376
            ASSETS[759487	SS2F2-1TAI-10	SS2F2-1	TAI-10	WASNR-BLDG1	759485	OPERATING	0376
            ASSETS[759488	SS2F2-1NOS-01	SS2F2-1	NOS-01	WASNR-BLDG1	759485	OPERATING	0376
            ASSETS[759489] = ASSETS_Module_Pattern("	SSDA-1PARENT	SSDA-1	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759490] = ASSETS_Module_Pattern("	SSDA-1DRI-34	SSDA-1	DRI-34	WASNR-BLDG1	759489	OPERATING	0376
            ASSETS[759491] = ASSETS_Module_Pattern("	SSDA-1TAI-10	SSDA-1	TAI-10	WASNR-BLDG1	759489	OPERATING	0376
            ASSETS[759492] = ASSETS_Module_Pattern("	SSDA-1TAI-10	SSDA-1	TAI-10	WASNR-BLDG1	759489	OPERATING	0376
            ASSETS[759493] = ASSETS_Module_Pattern("	DAR1-1PARENT	DAR1-1	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759494] = ASSETS_Module_Pattern("	DAR1-1DRI-12	DAR1-1	DRI-12	WASNR-BLDG1	759493	OPERATING	0376
            ASSETS[759495] = ASSETS_Module_Pattern("	DAR1-1TAI-10	DAR1-1	TAI-10	WASNR-BLDG1	759493	OPERATING	0376
            ASSETS[759496] = ASSETS_Module_Pattern("	DAR1-1NOS-01	DAR1-1	NOS-01	WASNR-BLDG1	759493	OPERATING	0376
            ASSETS[759497] = ASSETS_Module_Pattern("	DAR1-2PARENT	DAR1-2	PARENT	WASNR-BLDG1		OPERATING",0,0);
            ASSETS[759498] = ASSETS_Module_Pattern("	DAR1-2DRI-12	DAR1-2	DRI-12	WASNR-BLDG1	759497	OPERATING	0376
            ASSETS[759499] = ASSETS_Module_Pattern("	DAR1-2TAI-10	DAR1-2	TAI-10	WASNR-BLDG1	759497	OPERATING	0376
            ASSETS[759500] = ASSETS_Module_Pattern("	DAR1-2NOS-01	DAR1-2	NOS-01	WASNR-BLDG1	759497	OPERATING	0376
            ASSETS[759501] = ASSETS_Module_Pattern("	SSR1-1CPARENT	SSR1-1C	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759502] = ASSETS_Module_Pattern("	SSR1-1CDRI-43	SSR1-1C	DRI-43	WASNR-BLDG1	759501	OPERATING	0376
            ASSETS[759503] = ASSETS_Module_Pattern("	SSR1-1CTAI-10	SSR1-1C	TAI-10	WASNR-BLDG1	759501	OPERATING	0376
            ASSETS[759504] = ASSETS_Module_Pattern("	SSR1-2CPARENT	SSR1-2C	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759505] = ASSETS_Module_Pattern("	SSR1-2CDRI-43	SSR1-2C	DRI-43	WASNR-BLDG1	759504	OPERATING	0376
            ASSETS[759506] = ASSETS_Module_Pattern("	SSR1-2CTAI-10	SSR1-2C	TAI-10	WASNR-BLDG1	759504	OPERATING	0376
            ASSETS[759507] = ASSETS_Module_Pattern("	SSR1-3CPARENT	SSR1-3C	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759508] = ASSETS_Module_Pattern("	SSR1-3CDRI-43	SSR1-3C	DRI-43	WASNR-BLDG1	759507	OPERATING	0376
            ASSETS[759509] = ASSETS_Module_Pattern("	SSR1-3CTAI-10	SSR1-3C	TAI-10	WASNR-BLDG1	759507	OPERATING	0376
            ASSETS[759510] = ASSETS_Module_Pattern("	SSR1-3CHIT-08	SSR1-3C	HIT-08	WASNR-BLDG1	759507	OPERATING	0376
            ASSETS[759511] = ASSETS_Module_Pattern("	SSR1-3CNOS-01	SSR1-3C	NOS-01	WASNR-BLDG1	759507	OPERATING	0376
            ASSETS[759512] = ASSETS_Module_Pattern("	SSR1-4CPARENT	SSR1-4C	PARENT	WASNR-BLDG1		OPERATING	0376
            ASSETS[759513] = ASSETS_Module_Pattern("	SSR1-4CDRI-43	SSR1-4C	DRI-43	WASNR-BLDG1	759512	OPERATING	0376
            ASSETS[759514] = ASSETS_Module_Pattern("	SSR1-4CTAI-10	SSR1-4C	TAI-10	WASNR-BLDG1	759512	OPERATING	0376
            ASSETS[759515] = ASSETS_Module_Pattern("	SSR1-5CPARENT	SSR1-5C	PARENT	WASNR-BLDG1		OPERATING",0,0);
            ASSETS[759516] = ASSETS_Module_Pattern("	SSR1-5CDRI-43	SSR1-5C	DRI-43	WASNR-BLDG1	759515	OPERATING",0,0);
            ASSETS[759517] = ASSETS_Module_Pattern("	SSR1-5CTAI-10	SSR1-5C	TAI-10	WASNR-BLDG1	759515	OPERATING",0,0);
            ASSETS[770085] = ASSETS_Module_Pattern("	SSRO1-1P1-2SOR-02A	SSRO1-1	SOR-02	WASNR-BLDG1	759482	OPERATING",0,0);
            ASSETS[770089] = ASSETS_Module_Pattern("	GFGC-219GROUNDFAULT/GROUNDCONTINUITYPANEL	GFGC-219	ELECTRICAL	WASNR-BLDG1		OPERATING",0,0);
            ASSETS[762939] = ASSETS_Module_Pattern("	TRACTOR-GIRR-01	TRACTOR-G	IRR-01	WASNR-BLDG1		OPERATING",0,0);
            ASSETS[759671] = ASSETS_Module_Pattern("	GUD-1GUD-01	GUD-1	GUD-01	WASNR-BLDG1		OPERATING",0,0);
            */


    }

    function drawScene03() {
        gl03.useProgram(shaderProgramme);
        gl03.viewport(0, 0, gl03.viewportWidth, gl03.viewportHeight);
        gl03.clear(gl03.COLOR_BUFFER_BIT | gl03.DEPTH_BUFFER_BIT);



        if (true == document.getElementById("Project003").checked) {//WASNR
            gl03.useProgram(shaderProgramme);

            gl03.uniformMatrix4fv(shaderProgramme.Matrix_Projection_Uniform, false, Matrix_Projection);
            gl03.uniformMatrix4fv(shaderProgramme.Matrix_View_Uniform, false, Matrix_View);
            for (var key in ASSETS) {
                if (ASSETS.hasOwnProperty(key)) {
                    {//Base 2
                        //gl03.useProgram(shaderProgramme);
                        //ASSETS[00001]
                        //console.log("here we go");
                        // console.log(Component[1][0].itemSize);
                        // console.log(ASSETS[00001].component);
                        // console.log();
                        //console.log(Component[1][1].itemSize);
                        //console.log(ASSETS[00001].VC_Buffer.itemSize);
                        //console.log(Object.keys(ASSETS).length);
                        //console.log(ASSETS["00001"].Kd);
                        if (ASSETS[key].component in STD_DRAWINGS) {
                            //console.log(STD_DRAWINGS[ASSETS[key].component].VP_Buffer);
                            gl03.uniform3fv(shaderProgramme.Kd, ASSETS[key].Kd);
                            //gl03.uniform3fv(shaderProgramme.Kd, Component[1][2]);
                            // gl03.uniformMatrix4fv(shaderProgramme.Matrix_Projection_Uniform, false, Matrix_Projection);
                            // gl03.uniformMatrix4fv(shaderProgramme.Matrix_View_Uniform, false, Matrix_View);

                            mat4.identity(Maxtrix_Move);
                            //mat4.translate(Maxtrix_Move, Maxtrix_Move, [7.0, 8.0, -7.0]);
                            mat4.translate(Maxtrix_Move, Maxtrix_Move, ASSETS[key].POS);
                            gl03.bindBuffer(gl03.ARRAY_BUFFER, STD_DRAWINGS[ASSETS[key].component].VP_Buffer);
                            gl03.vertexAttribPointer(shaderProgramme.vertexPositionAttribute, STD_DRAWINGS[ASSETS[key].component].VP_Buffer.itemSize, gl03.FLOAT, false, 0, 0);
                            gl03.bindBuffer(gl03.ARRAY_BUFFER, STD_DRAWINGS[ASSETS[key].component].VC_Buffer);
                            gl03.vertexAttribPointer(shaderProgramme.vertexNormalsAttribute, STD_DRAWINGS[ASSETS[key].component].VC_Buffer.itemSize, gl03.FLOAT, false, 0, 0);

                            gl03.uniformMatrix4fv(shaderProgramme.Matrix_Model_Uniform, false, Maxtrix_Move);

                            gl03.drawArrays(gl03.TRIANGLES, 0, STD_DRAWINGS[ASSETS[key].component].VP_Buffer.numItems);
                        }
                    }
                }
            }


        }
    }

    var lastTime03 = 0;
    function animate03() {
        var timeNow = new Date().getTime();
        if (lastTime03 != 0) {
            var elapsed = timeNow - lastTime03;

            rTri03 += (90 * elapsed) / 1000.0;
            rSquare03 += (75 * elapsed) / 1000.0;
        }
        lastTime03 = timeNow;
    }

    function tick03() {
        requestAnimFrame(tick03);
        drawScene03();
        animate03();
    }
    function webGLStart() {
        var canvas = document.getElementById("FACILITY CANVAS");

        {
            var fovy = 67.0;
            var aspect = canvas.width / canvas.height;
            var near_clip = 0.1;
            var fov_rad = fovy * (2.0 * Math.PI) / 360.0;//ONE_DEG_IN_RAD;
            var range = Math.tan(fov_rad / 2.0) * near_clip;
            var sx = (2.0 * near_clip) / (range * aspect + range * aspect);
            var sy = near_clip / range;
            var sz = -(far_clip + near_clip) / (far_clip - near_clip);
            var pz = -(2.0 * far_clip * near_clip) / (far_clip - near_clip);
            Matrix_Projection = [sx, 0, 0, 0,
                                    0, sy, 0, 0,
                                    0, 0, sz, -1.0,
                                    0, 0, pz, 0];
            Matrix_View = [1, 0, 0, 0,
                                    0, 1, 0, 0,
                                    0, 0, 1, 0,
                                    0, 0, 0, 1];
        }

        initGL03(canvas);
        //initShaders03();
        initShaders();
        initBuffers03();


        gl03.clearColor(0.0, 0.0, 0.0, 1.0);
        gl03.enable(gl03.DEPTH_TEST);


        canvas.onmousedown = handleMouseDown;
        document.onmouseup = handleMouseUp;
        document.onmousemove = handleMouseMove;
        document.onkeypress = handleKeyPress;
        canvas.addEventListener("mousewheel", rotateimage, false)
        tick03();
    }
    function rotateimage(e) {
        var evt = window.event || e //equalize event object
        var delta = evt.detail ? evt.detail * (-120) : evt.wheelDelta //delta returns +120 when wheel is scrolled up, -120 when scrolled down
        //nextslideindex=(delta<=-120)? nextslideindex+1 : nextslideindex-1 //move image index forward or back, depending on whether wheel is scrolled down or up
        //nextslideindex=(nextslideindex<0)? myimages.length-1 : (nextslideindex>myimages.length-1)? 0 : nextslideindex //wrap image index around when it goes beyond lower and upper boundaries
        //slideshow.src=myimages[nextslideindex]
        if (evt.preventDefault) //disable default wheel action of scrolling page
            evt.preventDefault()
        else
            return false

    }
    var mouseDown = false;
    var lastMouseX = null;
    var lastMouseY = null;

    function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }
    function handleMouseUp(event) {
        mouseDown = false;
    }
    var direction = vec3.create();
    function handleKeyPress(event) {
        var Unicode_KeyPress = event.which;
        if (Unicode_KeyPress == 97)//a
        {
            direction = [-10, 0, 0];
        }
        else if (Unicode_KeyPress == 100)//d
        {
            direction = [10, 0, 0];
        }
        else if (Unicode_KeyPress == 115)//s
        {
            direction = [0, 0, -10];
        }
        else if (Unicode_KeyPress == 119)//w
        {
            direction = [0, 0, 10];
        }
        else if (Unicode_KeyPress == 114)//r
        {
            direction = [0, 10, 0];
        }
        else if (Unicode_KeyPress == 102)//f
        {
            direction = [0, -10, 0];
        }
        else if (Unicode_KeyPress == 122)//z
        {
            vec3.copy(z_eye, m_eye);
            direction = [0, 0, 0];
        }
        else if (Unicode_KeyPress == 108)//l
        {
            if (Heightmap_Texture) Heightmap_Texture = 0;
            else Heightmap_Texture = 1;
            direction = [0, 0, 0];
        }
        else direction = [0, 0, 0];
        //document.getElementById("hello").innerHTML=event.which;

        var forwards = vec3.create();
        forwards = vec3.cross(forwards, WORLD_YAXIS, m_xAxis);
        vec3.normalize(forwards, forwards);
        var eye = vec3.create();
        vec3.copy(eye, m_eye);
        vec3.scaleAndAdd(eye, eye, m_xAxis, direction[0]);
        vec3.scaleAndAdd(eye, eye, WORLD_YAXIS, direction[1]);
        vec3.scaleAndAdd(eye, eye, forwards, direction[2]);
        vec3.copy(m_eye, eye);

        //BEGIN UPDATE VIEW MATRIX//
        mat4.fromQuat(Matrix_View, [m_orientation[1], m_orientation[2], m_orientation[3], m_orientation[0]]);
        m_xAxis = [Matrix_View[0], Matrix_View[4], Matrix_View[8]];
        m_yAxis = [Matrix_View[1], Matrix_View[5], Matrix_View[9]];
        m_zAxis = [Matrix_View[2], Matrix_View[6], Matrix_View[10]];
        m_viewDir = -m_zAxis;
        Matrix_View[12] = -vec3.dot(m_xAxis, m_eye);
        Matrix_View[13] = -vec3.dot(m_yAxis, m_eye);
        Matrix_View[14] = -vec3.dot(m_zAxis, m_eye);
        //END UPDATE VIEW MATRIX//
        return;
    }
    function handleMouseMove(event) {
        if (!mouseDown) {
            return;
        }
        var newX = event.clientX;
        var newY = event.clientY;
        var heading = newX - lastMouseX;
        var pitch = newY - lastMouseY;

        if (heading != 0.0) {
            var rot = quat.create();
            quat.setAxisAngle(rot, WORLD_YAXIS, degToRad(heading));
            rot = [rot[3], rot[0], rot[1], rot[2]];
            m_orientation = quat.product(rot, m_orientation);
        }
        if (pitch != 0.0) {
            var rot = quat.create();
            quat.setAxisAngle(rot, WORLD_XAXIS, degToRad(pitch));
            rot = [rot[3], rot[0], rot[1], rot[2]];
            m_orientation = quat.product(m_orientation, rot);
        }

        //BEGIN UPDATE VIEW MATRIX//
        mat4.fromQuat(Matrix_View, [m_orientation[1], m_orientation[2], m_orientation[3], m_orientation[0]]);
        m_xAxis = [Matrix_View[0], Matrix_View[4], Matrix_View[8]];
        m_yAxis = [Matrix_View[1], Matrix_View[5], Matrix_View[9]];
        m_zAxis = [Matrix_View[2], Matrix_View[6], Matrix_View[10]];
        m_viewDir = -m_zAxis;
        Matrix_View[12] = -vec3.dot(m_xAxis, m_eye);
        Matrix_View[13] = -vec3.dot(m_yAxis, m_eye);
        Matrix_View[14] = -vec3.dot(m_zAxis, m_eye);
        //END UPDATE VIEW MATRIX//
        //mouse.move to lastMouseX, lastMouseY instead of below stuff

        lastMouseX = newX
        lastMouseY = newY;

    }





</script>


<!--UPS_WASEA_PMI_HEURISTICS-canvas>-->

<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>WebGL Test</title>
		<link rel="stylesheet" type="text/css" href="style2.css">
		<!-- [if lt IE 9]>
		<script>
			document.createElement("article");
			document.createElement("aside");
			document.createElement("footer");
			document.createElement("header");
			document.createElement("main");
			document.createElement("nav");
			document.createElement("section");
		</script>
		<![endif]-->
	</head>
	<body onload="webGLStart();">
		<header class="banner">
			<h1></h1>
			<p>Slide Fabrication</p>
		</header>
		
		<!--<nav>
			<ul>
				<li><a href ="index.html">Home</a></li>
				<li><a href ="archive.html">Archives</a></li>
				<li><a href ="about.html">About</a></li>
			</ul>
		</nav>-->
		
		<main>




					<div>
				<section>
					
						<h1 id="ProjectTitle"><br> </h1>
					
			
					<p><canvas id="FACILITY CANVAS" style="border: none;" width="500" height="500"></canvas></p>
				</section>
			</div>
			
		</main>
		
		<aside>
			<h2>Environment Controls</h2>
			<p>Pending [Keyboard WASD + RF]<br><br></p>
			<h2>Project</h2>
			<form name="ProjectSelectForm">
			
			
            <p><input type="radio" name="ProjectSelectRadio" id="Project003" checked="checked">Slide</p>
			</form>
		</aside>
<script>
var rad = document.ProjectSelectForm.ProjectSelectRadio;
var prev = null;
for(var i = 0; i < rad.length; i++) {
    rad[i].onclick = function() {
        (prev)? console.log(prev.value):null;
        if(this !== prev) {
            prev = this;
        }
		document.getElementById("ProjectTitle").innerHTML="Project"+this.innerHTML;
        console.log(this.value)
    };
}
</script>
	        		
		<footer>
			<p>
			Richard Aaron Shaw
			C:432.266.1455
			</p>
		</footer>
		
	</body>
</html>














